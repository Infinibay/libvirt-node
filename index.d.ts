/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export const enum VirDomainGetHostnameFlags {
  /** Parse DHCP lease file */
  VirDomainGetHostnameLease = 1,
  /** Query qemu guest agent */
  VirDomainGetHostnameAgent = 2
}
export const enum VirDomainXMLFlags {
  /** dump security sensitive information too */
  VirDomainXMLSecure = 1,
  /** dump inactive domain information */
  VirDomainXMLInactive = 2,
  /** update guest CPU requirements according to host CPU */
  VirDomainXMLUpdateCPU = 4,
  /** dump XML suitable for migration */
  VirDomainXMLMigratable = 8
}
export const enum VirDomainCreateFlags {
  /** Default behavior */
  VirDomainNone = 0,
  /** Launch guest in paused state */
  VirDomainStartPaused = 1,
  /** Automatically kill guest when virConnectPtr is closed */
  VirDomainStartAutodestroy = 2,
  /** Avoid file system cache pollution */
  VirDomainStartBypassCache = 4,
  /** Boot, discarding any managed save */
  VirDomainStartForceBoot = 8,
  /** Validate the XML document against schema */
  VirDomainStartValidate = 16,
  /** Re-initialize NVRAM from template */
  VirDomainStartResetNvram = 32
}
export const enum VirDomainDefineFlags {
  /** Validate the XML document against schema */
  VirDomainDefineValidate = 1
}
export const enum VirDomainDestroyFlags {
  /** Default behavior - could lead to data loss!! */
  VirDomainDestroyDefault = 0,
  /** Only SIGTERM, no SIGKILL */
  VirDomainDestroyGraceful = 1,
  /** Remove VM logs on destroy */
  VirDomainDestroyRemoveLogs = 2
}
export const enum VirDomainRebootFlag {
  /** Hypervisor choice */
  VirDomainRebootDefault = 0,
  /** Send ACPI event */
  VirDomainRebootAcpiPowerBtn = 1,
  /** Use guest agent */
  VirDomainRebootGuestAgent = 2,
  /** Use initctl */
  VirDomainRebootInitctl = 4,
  /** Send a signal */
  VirDomainRebootSignal = 8,
  /** Use paravirt guest control */
  VirDomainRebootParavirt = 16
}
export const enum VirDomainUndefineFlags {
  /** Also remove any managed save */
  VirDomainUndefineManagedSave = 1,
  /** If last use of domain, then also remove any snapshot metadata */
  VirDomainUndefineSnapshotsMetadata = 2,
  /** Also remove any nvram file */
  VirDomainUndefineNvram = 4,
  /** Keep nvram file */
  VirDomainUndefineKeepNvram = 8,
  /** If last use of domain, then also remove any checkpoint metadata */
  VirDomainUndefineCheckpointsMetadata = 16,
  /** Also remove any TPM state */
  VirDomainUndefineTpm = 32,
  /** Keep TPM state */
  VirDomainUndefineKeepTpm = 64
}
export const enum VirDomainModificationImpact {
  /** Affect current domain state */
  VirDomainAffectCurrent = 0,
  /** Affect running domain state */
  VirDomainAffectLive = 1,
  /** Affect persistent domain state */
  VirDomainAffectConfig = 2
}
export const enum VirDomainMemoryModFlags {
  /** See virDomainModificationImpact */
  VirDomainMemConfig = 2,
  /** See virDomainModificationImpact */
  VirDomainMemCurrent = 0,
  /** See virDomainModificationImpact */
  VirDomainMemLive = 1,
  /** Affect Max rather than current */
  VirDomainMemMaximum = 4
}
export const enum VirStoragePoolCreateFlags {
  /** Default behavior */
  VirStoragePoolCreateNormal = 0,
  /** Create pool from XML, build it */
  VirStoragePoolCreateWithBuild = 1,
  /** Create pool from XML, build it and overwrite if exists */
  VirStoragePoolCreateWithBuildOverwrite = 2,
  /** Create pool from XML, build it and do not overwrite if exists */
  VirStoragePoolCreateWithBuildNoOverwrite = 4
}
export const enum VirStorageXMLFlags {
  /** Inactive */
  VirStorageXMLInactive = 1
}
/**
 * The level of an error.
 *
 * See <https://libvirt.org/html/libvirt-virterror.html#virErrorLevel>
 */
export const enum ErrorLevel {
  /** No error. */
  None = 0,
  /** A simple warning. */
  Warning = 1,
  /** An error. */
  Error = 2
}
/**
 * An enumeration of all possible origins of an error.
 *
 * See <https://libvirt.org/html/libvirt-virterror.html#virErrorDomain>
 */
export const enum ErrorDomain {
  /** No error. */
  None = 0,
  /** Error at Xen hypervisor layer */
  Xen = 1,
  /** Error at connection with xend daemon */
  Xend = 2,
  /** Error at connection with xen store */
  XenStore = 3,
  /** Error in the S-Expression code */
  SExpr = 4,
  /** Error in the XML code */
  Xml = 5,
  /** Error when operating on a domain */
  Dom = 6,
  /** Error in the XML-RPC code */
  Rpc = 7,
  /** Error in the proxy code; unused since 0.8.6 */
  Proxy = 8,
  /** Error in the configuration file handling */
  Conf = 9,
  /** Error at the QEMU daemon */
  Qemu = 10,
  /** Error when operating on a network */
  Net = 11,
  /** Error from test driver */
  Test = 12,
  /** Error from remote driver */
  Remote = 13,
  /** Error from OpenVZ driver */
  OpenVz = 14,
  /** Error at Xen XM layer */
  XenXm = 15,
  /** Error in the Linux Stats code */
  StatsLinux = 16,
  /** Error from Linux Container driver */
  Lxc = 17,
  /** Error from storage driver */
  Storage = 18,
  /** Error from network config */
  Network = 19,
  /** Error from domain config */
  Domain = 20,
  /** Error at the UML driver; unused since 5.0.0 */
  Uml = 21,
  /** Error from node device monitor */
  Nodedev = 22,
  /** Error from xen inotify layer */
  XenINotify = 23,
  /** Error from security framework */
  Security = 24,
  /** Error from VirtualBox driver */
  VBox = 25,
  /** Error when operating on an interface */
  Interface = 26,
  /** The OpenNebula driver no longer exists. Retained for ABI/API compat only */
  ONe = 27,
  /** Error from ESX driver */
  Esx = 28,
  /** Error from the phyp driver, unused since 6.0.0 */
  Phyp = 29,
  /** Error from secret storage */
  Secret = 30,
  /** Error from CPU driver */
  Cpu = 31,
  /** Error from XenAPI */
  XenApi = 32,
  /** Error from network filter driver */
  Nwfilter = 33,
  /** Error from Synchronous hooks */
  Hook = 34,
  /** Error from domain snapshot */
  DomainSnapshot = 35,
  /** Error from auditing subsystem */
  Audit = 36,
  /** Error from sysinfo/SMBIOS */
  SysInfo = 37,
  /** Error from I/O streams */
  Streams = 38,
  /** Error from VMware driver */
  Vmware = 39,
  /** Error from event loop impl */
  Event = 40,
  /** Error from libxenlight driver */
  Libxl = 41,
  /** Error from lock manager */
  Locking = 42,
  /** Error from Hyper-V driver */
  HyperV = 43,
  /** Error from capabilities */
  Capabilities = 44,
  /** Error from URI handling */
  Uri = 45,
  /** Error from auth handling */
  Auth = 46,
  /** Error from DBus */
  Dbus = 47,
  /** Error from Parallels */
  Parallels = 48,
  /** Error from Device */
  Device = 49,
  /** Error from libssh2 connection transport */
  Ssh = 50,
  /** Error from lockspace */
  Lockspace = 51,
  /** Error from initctl device communication */
  Initctl = 52,
  /** Error from identity code */
  Identity = 53,
  /** Error from cgroups */
  Cgroup = 54,
  /** Error from access control manager */
  Access = 55,
  /** Error from systemd code */
  Systemd = 56,
  /** Error from bhyve driver */
  Bhyve = 57,
  /** Error from crypto code */
  Crypto = 58,
  /** Error from firewall */
  Firewall = 59,
  /** Error from polkit code */
  Polkit = 60,
  /** Error from thread utils */
  Thread = 61,
  /** Error from admin backend */
  Admin = 62,
  /** Error from log manager */
  Logging = 63,
  /** Error from Xen xl config code */
  XenXl = 64,
  /** Error from perf */
  Perf = 65,
  /** Error from libssh connection transport */
  Libssh = 66,
  /** Error from resource control */
  ResCtrl = 67,
  /** Error from firewalld */
  Firewalld = 68,
  /** Error from domain checkpoint */
  DomainCheckpoint = 69,
  /** Error from TPM */
  Tpm = 70,
  /** Error from BPF code */
  Bpf = 71,
  /** Error from Cloud Hypervisor driver */
  Ch = 72,
  /** Indicates an error domain not yet supported by the Rust bindings */
  Last = 73
}
/**
 * An enumeration of all possible errors.
 *
 * See <https://libvirt.org/html/libvirt-virterror.html#virErrorNumber>
 */
export const enum ErrorNumber {
  /** No error. */
  Ok = 0,
  /** Internal error */
  InternalError = 1,
  /** Memory allocation failure */
  NoMemory = 2,
  /** No support for this function */
  NoSupport = 3,
  /** Could not resolve hostname */
  UnknownHost = 4,
  /** Can't connect to hypervisor */
  NoConnect = 5,
  /** Invalid connection object */
  InvalidConn = 6,
  /** Invalid domain object */
  InvalidDomain = 7,
  /** Invalid function argument */
  InvalidArg = 8,
  /** A command to hypervisor failed */
  OperationFailed = 9,
  /** A HTTP GET command to failed */
  GetFailed = 10,
  /** A HTTP POST command to failed */
  PostFailed = 11,
  /** Unexpected HTTP error code */
  HttpError = 12,
  /** Failure to serialize an S-Expr */
  SExprSerial = 13,
  /** Could not open Xen hypervisor control */
  NoXen = 14,
  /** Failure doing an hypervisor call */
  XenCall = 15,
  /** Unknown OS type */
  OsType = 16,
  /** Missing kernel information */
  NoKernel = 17,
  /** Missing root device information */
  NoRoot = 18,
  /** Missing source device information */
  NoSource = 19,
  /** Missing target device information */
  NoTarget = 20,
  /** Missing domain name information */
  NoName = 21,
  /** Missing domain OS information */
  NoOs = 22,
  /** Missing domain devices information */
  NoDevice = 23,
  /** Could not open Xen Store control */
  NoXenStore = 24,
  /** Too many drivers registered */
  DriverFull = 25,
  /** Not supported by the drivers (DEPRECATED) */
  CallFailed = 26,
  /** An XML description is not well formed or broken */
  XmlError = 27,
  /** The domain already exist */
  DomExist = 28,
  /** Operation forbidden on read-only connections */
  OperationDenied = 29,
  /** Failed to open a conf file */
  OpenFailed = 30,
  /** Failed to read a conf file */
  ReadFailed = 31,
  /** Failed to parse a conf file */
  ParseFailed = 32,
  /** Failed to parse the syntax of a conf file */
  ConfSyntax = 33,
  /** Failed to write a conf file */
  WriteFailed = 34,
  /** Detail of an XML error */
  XmlDetail = 35,
  /** Invalid network object */
  InvalidNetwork = 36,
  /** The network already exist */
  NetworkExist = 37,
  /** General system call failure */
  SystemError = 38,
  /** Some sort of RPC error */
  Rpc = 39,
  /** Error from a GNUTLS call */
  GnutlsError = 40,
  /** Failed to start network */
  NoNetworkStart = 41,
  /** Domain not found or unexpectedly disappeared */
  NoDomain = 42,
  /** Network not found */
  NoNetwork = 43,
  /** Invalid MAC address */
  InvalidMac = 44,
  /** Authentication failed */
  AuthFailed = 45,
  /** Invalid storage pool object */
  InvalidStoragePool = 46,
  /** Invalid storage vol object */
  InvalidStorageVol = 47,
  /** Failed to start storage */
  NoStorage = 48,
  /** Storage pool not found */
  NoStoragePool = 49,
  /** Storage volume not found */
  NoStorageVolume = 50,
  /** Failed to start node driver */
  NoNode = 51,
  /** Invalid node device object */
  InvalidNodeDevice = 52,
  /** Node device not found */
  NoNodeDevice = 53,
  /** Security model not found */
  NoSecurityModel = 54,
  /** Operation is not applicable at this time */
  OperationInvalid = 55,
  /** Failed to start interface driver */
  NoInterfaceStart = 56,
  /** Interface driver not running */
  NoInterface = 57,
  /** Invalid interface object */
  InvalidInterface = 58,
  /** More than one matching interface found */
  MultipleInterfaces = 59,
  /** Failed to start nwfilter driver */
  NoNwfilterStart = 60,
  /** Invalid nwfilter object */
  InvalidNwfilter = 61,
  /** Nw filter pool not found */
  NoNwfilter = 62,
  /** Failed to build firewall */
  BuildFirewall = 63,
  /** Failed to start secret storage */
  NoSecretStart = 64,
  /** Invalid secret */
  InvalidSecret = 65,
  /** Secret not found */
  NoSecret = 66,
  /** Unsupported configuration construct */
  ConfigUnsupported = 67,
  /** Timeout occurred during operation */
  OperationTimeout = 68,
  /** A migration worked, but making the VM persist on the dest host failed */
  MigratePersistFailed = 69,
  /** A synchronous hook script failed */
  HookScriptFailed = 70,
  /** Invalid domain snapshot */
  InvalidDomainSnapshot = 71,
  /** Domain snapshot not found */
  NoDomainSnapshot = 72,
  /** Stream pointer not valid */
  InvalidStream = 73,
  /** Valid API use but unsupported by the given driver */
  ArgumentUnsupported = 74,
  /** Storage pool probe failed */
  StorageProbeFailed = 75,
  /** Storage pool already built */
  StoragePoolBuilt = 76,
  /** Force was not requested for a risky domain snapshot revert */
  SnapshotRevertRisky = 77,
  /** Operation on a domain was canceled/aborted by user */
  OperationAborted = 78,
  /** Authentication cancelled */
  AuthCancelled = 79,
  /** The metadata is not present */
  NoDomainMetadata = 80,
  /** Migration is not safe */
  MigrateUnsafe = 81,
  /** Integer overflow */
  Overflow = 82,
  /** Action prevented by block copy job */
  BlockCopyActive = 83,
  /** The requested operation is not supported */
  OperationUnsupported = 84,
  /** Error in ssh transport driver */
  Ssh = 85,
  /** Guest agent is unresponsive, not running or not usable */
  AgentUnresponsive = 86,
  /** Resource is already in use */
  ResourceBusy = 87,
  /** Operation on the object/resource was denied */
  AccessDenied = 88,
  /** Error from a dbus service */
  DbusService = 89,
  /** The storage vol already exists */
  StorageVolExist = 90,
  /** Given CPU is incompatible with host CPU */
  CpuIncompatible = 91,
  /** XML document doesn't validate against schema */
  XmlInvalidSchema = 92,
  /** Finish API succeeded but it is expected to return NULL */
  MigrateFinishOk = 93,
  /** Authentication unavailable */
  AuthUnavailable = 94,
  /** Server was not found */
  NoServer = 95,
  /** Client was not found */
  NoClient = 96,
  /** Guest agent replies with wrong id to guest-sync command (DEPRECATED) */
  AgentUnsynced = 97,
  /** Error in libssh transport driver */
  Libssh = 98,
  /** Fail to find the desired device */
  DeviceMissing = 99,
  /** Invalid nwfilter binding */
  InvalidNwfilterBinding = 100,
  /** No nwfilter binding */
  NoNwfilterBinding = 101,
  /** Invalid domain checkpoint */
  InvalidDomainCheckpoint = 102,
  /** Domain checkpoint not found */
  NoDomainCheckpoint = 103,
  /** Domain backup job id not found */
  NoDomainBackup = 104,
  /** Invalid network port object */
  InvalidNetworkPort = 105,
  /** The network port already exist */
  NetworkPortExists = 106,
  /** Network port not found */
  NoNetworkPort = 107,
  /** No domain's hostname found */
  NoHostname = 108,
  /** Checkpoint can't be used */
  CheckpointInconsistent = 109,
  /** More than one matching domain found */
  MultipleDomains = 110,
  /** Network metadata is not present */
  NoNetworkMetadata = 111,
  /** Indicates an error number not yet supported by the Rust bindings */
  Last = 112
}
export declare class Connection {
  static open(name: string): Connection | null
  close(): number
  isAlive(): boolean | null
  getSysInfo(flags: number): string | null
  getMaxVcpus(attr: string): number | null
  getCpuModelsNames(arch: string, flags: number): Array<string> | null
  isEncrypted(): boolean | null
  isSecure(): boolean | null
  listActiveDomainIds(): Array<number> | null
  listInterfaces(): Array<string> | null
  listNetworks(): Array<string> | null
  listNwFilters(): Array<string> | null
  listSecrets(): Array<string> | null
  listStoragePools(): Array<string> | null
  listAllDomains(flags: number): Array<Machine> | null
  listAllNetworks(flags: number): Array<Network> | null
  listAllInterfaces(flags: number): Array<Interface> | null
  listAllNodeDevices(flags: number): Array<NodeDevice> | null
  listAllSecrets(flags: number): Array<Secret> | null
  listAllStoragePools(flags: number): Array<StoragePool> | null
  listAllNwFilters(flags: number): Array<NWFilter> | null
  listDefinedDomains(): Array<string> | null
  listDefinedInterfaces(): Array<string> | null
  listDefinedStoragePools(): Array<string> | null
  listDefinedNetworks(): Array<string> | null
  numOfDomains(): number | null
  numOfInterfaces(): number | null
  numOfNetworks(): number | null
  numOfStoragePools(): number | null
  numOfNwFilters(): number | null
  numOfSecrets(): number | null
  numOfNodeDevices(): number | null
  numOfDefinedDomains(): number | null
  numOfDefinedInterfaces(): number | null
  numOfDefinedNetworks(): number | null
  getHypVersion(): number | null
  compareCpu(xml: string, flags: number): number | null
  getFreeMemory(): bigint | null
  getNodeInfo(): NodeInfo | null
  setKeepAlive(interval: number, count: number): number | null
  domainXmlFromNative(nformat: string, nconfig: string, flags: number): string | null
  domainXmlToNative(nformat: string, dxml: string, flags: number): string | null
  getDomainCapabilities(emulatorbin: string, arch: string, machine: string, virttype: string, flags: number): string | null
  getAllDomainStats(stats: number, flags: number): Array<DomainStatsRecord> | null
  baselineCpu(xmlcpus: Array<string>, flags: number): string | null
  findStoragePoolSources(kind: string, spec: string, flags: number): string | null
}
/** Represents a virtual machine. */
export declare class Machine {
  /**
   * Looks up a domain by its name.
   *
   * # Arguments
   *
   * * `con` - A reference to the Connection object.
   * * `name` - A String that holds the name of the domain.
   *
   * # Returns
   *
   * This function returns a `napi::Result` which is:
   * * `Ok(Machine)` - If the domain is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function lookupDomain() {
   *   const conn = await Connection.open('qemu:///system');
   *   try {
   *     const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *     console.log('Domain found:', machine);
   *   } catch (err) {
   *     console.error('Error looking up domain:', err);
   *   }
   * }
   *
   * lookupDomain();
   * ```
   */
  static lookupByName(con: Connection, name: string): Machine | null
  /**
   * Looks up a domain by its ID.
   *
   * # Arguments
   *
   * * `conn` - A reference to the Connection object.
   * * `id` - The ID of the domain.
   *
   * # Returns
   *
   * This function returns a `napi::Result` which is:
   * * `Ok(Machine)` - If the domain is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function lookupDomainById() {
   *   const conn = Connection.open('qemu:///system');
   *   try {
   *     const machine = await Machine.lookupById(conn, 1); // Replace 1 with your domain ID
   *     console.log('Domain found:', machine);
   *   } catch (err) {
   *     console.error('Error looking up domain by ID:', err);
   *   } finally {
   *     conn.close();
   *   }
   * }
   *
   * lookupDomainById();
   * ```
   */
  static lookupById(conn: Connection, id: number): Machine | null
  /**
   * Looks up a domain by its UUID.
   *
   * # Arguments
   *
   * * `conn` - A reference to the Connection object.
   * * `uuid` - The UUID of the domain as a string.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(Machine)` - If the domain is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function lookupDomainByUuid() {
   *   const conn = Connection.open('qemu:///system');
   *   try {
   *     const machine = Machine.lookupByUuidString(conn, 'your-domain-uuid');
   *     console.log('Domain found:', machine);
   *   } catch (err) {
   *     console.error('Error looking up domain by UUID:', err);
   *   } finally {
   *     conn.close();
   *   }
   * }
   *
   * lookupDomainByUuid();
   * ```
   */
  static lookupByUuidString(conn: Connection, uuid: string): Machine | null
  /**
   * Get the state of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(StateResult)` - If the state is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   * const VIR_DOMAIN_RUNNING = 1;
   *
   * async function getDomainState() {
   *   const conn = Connection.open('quemu:///system');
   *   try {
   *     const machine = Machine.lookupByName(conn, 'your-domain-name');
   *     const state = machine.getState();
   *     if (state.result === VIR_DOMAIN_RUNNING) {
   *       console.log('Domain is running');
   *     } else {
   *       console.log('Domain is not running');
   *     }
   *   } catch (err) {
   *     console.error('Error looking up domain by UUID:', err);
   *   }
   * }
   *
   * getDomainState();
   * ```
   */
  getState(): StateResult | null
  /**
   * Get the name of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(String)` - If the name is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainName() {
   *   const conn = Connection.open('qemu:///system');
   *   try {
   *     const machine = Machine.lookupByName(conn, 'your-domain-name');
   *     const name = machine.getName();
   *     console.log('Domain name:', name);
   *   } catch (err) {
   *     console.error('Error getting domain name:', err);
   *   } finally {
   *     conn.close();
   *   }
   * }
   *
   * getDomainName();
   * ```
   */
  getName(): string | null
  /**
   * Get the OS type of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(String)` - If the OS type is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainOsType() {
   *   const conn = Connection.open('qemu:///system');
   *   try {
   *     const machine = Machine.lookupByName(conn, 'your-domain-name');
   *     const osType = machine.getOsType();
   *     console.log('Domain OS type:', osType);
   *   } catch (err) {
   *     console.error('Error getting domain OS type:', err);
   *   } finally {
   *     conn.close();
   *   }
   * }
   *
   * getDomainOsType();
   * ```
   */
  getOsType(): string | null
  /**
   * Get the hostname of the domain.
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the lookup. Use VirDomainGetHostnameFlags enum.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(String)` - If the hostname is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainHostname() {
   *   const conn = Connection.open('qemu:///system');
   *   try {
   *     const machine = Machine.lookupByName(conn, 'your-domain-name');
   *     const hostname = machine.getHostname(0);
   *     console.log('Domain hostname:', hostname);
   *   } catch (err) {
   *     console.error('Error getting domain hostname:', err);
   *   } finally {
   *     conn.close();
   *   }
   * }
   *
   * getDomainHostname();
   * ```
   */
  getHostname(flags: number): string | null
  /**
   * Get the UUID of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(String)` - If the UUID is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainUuid() {
   *   const conn = Connection.open('qemu:///system');
   *   try {
   *     const machine = Machine.lookupByName(conn, 'your-domain-name');
   *     const uuid = machine.getUuidString();
   *     console.log('Domain UUID:', uuid);
   *   } catch (err) {
   *     console.error('Error getting domain UUID:', err);
   *   } finally {
   *     conn.close();
   *   }
   * }
   *
   * getDomainUuid();
   * ```
   */
  getUuidString(): string | null
  /**
   * Get the ID of the domain.
   *
   * # Returns
   *
   * This function returns an `Option<u32>` which is:
   * * `Some(u32)` - If the ID is found.
   * * `None` - If the domain is not running or doesn't have an ID assigned.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainId() {
   *   const conn = Connection.open('qemu:///system');
   *   try {
   *     const machine = Machine.lookupByName(conn, 'your-domain-name');
   *     const id =.getId();
   *     if (id !== null) {
   *       console.log('Domain ID:', id);
   *     } else {
   *       console.log('Domain is not running or has no ID assigned');
   *     }
   *   } catch (err) {
   *     console.error('Error:', err);
   *   } finally {
   *     conn.close();
   *   }
   * }
   *
   * getDomainId();
   * ```
   */
  getId(): number | null
  /**
   * Get the XML description of the domain.
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the lookup. Use VirDomainXMLFlags enum.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(String)` - If the XML description is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainXml() {
   *   const conn = Connection.open('qemu:///system');
   *   try {
   *     const machine = Machine.lookupByName(conn, 'your-domain-name');
   *     const xml = machine.getXmlDesc(0); // Pass appropriate flags
   *     console.log('Domain XML:', xml);
   *   } catch (err) {
   *     console.error('Error:', err);
   *   } finally {
   *     conn.close();
   *   }
   * }
   *
   * getDomainXml();
   * ```
   */
  getXmlDesc(flags: number): string | null
  /**
   * Create/power-on the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is created successfully, returns the domain ID.
   * * `Err(napi::Error)` - If there is an error during the creation.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function createDomain() {
   *   const conn = Connection.open('qemu:///system');
   *   try {
   *     const machine = Machine.lookupByName(conn, 'your-domain-name');
   *     const domainId = machine.create();
   *     console.log('Domain created with ID:', domainId);
   *   } catch (err) {
   *     console.error('Error creating domain:', err);
   *   } finally {
   *     conn.close();
   *   }
   * }
   *
   * createDomain();
   * ```
   */
  create(): number | null
  /**
   * Create/power-on the domain with flags.
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the creation. Use VirDomainCreateFlags enum.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is created successfully, returns the domain ID.
   * * `Err(napi::Error)` - If there is an error during the creation.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * const VIR_DOMAIN_START_PAUSED = 1;
   *
   * async function createDomainWithFlags() {
   *   const conn = Connection.open('qemu:///system');
   *   try {
   *     const machine = Machine.lookupByName(conn, 'your-domain-name');
   *     const domainId = machine.createWithFlags(VIR_DOMAIN_START_PAUSED);
   *     console.log('Domain created with ID:', domainId);
   *   } catch (err) {
   *     console.error('Error creating domain:', err);
   *   } finally {
   *     conn.close();
   *   }
   * }
   *
   * createDomainWithFlags();
   * ```
   */
  createWithFlags(flags: number): number | null
  /**
   * Get the information of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(MachineInfo)` - If the information is retrieved successfully.
   * * `Err(napi::Error)` - If there is an error during the retrieval.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainInfo() {
   *   const conn = Connection.open('qemu:///system');
   *   try {
   *     const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *     const info = machine.getInfo();
   *     console.log('Domain info:', info);
   *   } catch (err) {
   *     console.error('Error:', err);
   *   } finally {
   *     conn.close();
   *   }
   * }
   *
   * getDomainInfo();
   * ```
   */
  getInfo(): MachineInfo | null
  /**
   * Create a domain from an XML description.
   *
   * # Arguments
   *
   * * `xml` - The XML description of the domain.
   * * `flags` - The flags to use for the creation. Use VirDomainCreateFlags enum
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(Machine)` - If the domain is created.
   * * `Err(napi::Error)` - If there is an error during the creation.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function createDomainFromXml() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = Machine.createXml(conn, 'your-domain-xml', 0);
   *   // Now, we can power on the domain
   *   machine.create();
   * }
   *
   * createDomainFromXml();
   * ```
   */
  static createXml(conn: Connection, xml: string, flags: number): Machine | null
  /**
   * Define a domain from an XML description.
   *
   * # Arguments
   *
   * * `conn` - The Connection object to use.
   * * `xml` - The XML description of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(Machine)` - If the domain is defined successfully.
   * * `Err(napi::Error)` - If there is an error during the definition.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function defineDomainFromXml() {
   *   const conn = Connection.open('qemu:///system');
   *   const machine = Machine.defineXml(conn, 'your-domain-xml');
   *   console.log('Domain defined successfully');
   * }
   *
   * defineDomainFromXml().catch(console.error);
   * ```
   */
  static defineXml(conn: Connection, xml: string): Machine | null
  /**
   * Define a domain from an XML description with flags.
   *
   * # Arguments
   *
   * * `conn` - The Connection object to use.
   * * `xml` - The XML description of the domain.
   * * `flags` - The flags to use for the definition. Use VirDomainDefineFlags enum.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(Machine)` - If the domain is defined successfully.
   * * `Err(napi::Error)` - If there is an error during the definition.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine, VirDomainDefineFlags } = require('your-node-package');
   *
   * async function defineDomainFromXmlWithFlags() {
   *   const conn = Connection.open('qemu:///system');
   *   const flags = VirDomainDefineFlags.VIR_DOMAIN_DEFINE_VALIDATE;
   *   const machine = Machine.defineXmlFlags(conn, 'your-domain-xml', flags);
   *   console.log('Domain defined successfully with flags');
   * }
   *
   * defineDomainFromXmlWithFlags().catch(console.error);
   * ```
   */
  static defineXmlFlags(conn: Connection, xml: string, flags: number): Machine | null
  /**
   * Destroy/power-off the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(())` - If the domain is destroyed.
   * * `Err(napi::Error)` - If there is an error during the destruction.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function destroyDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.destroy();
   * }
   *
   * destroyDomain();
   * ```
   */
  destroy(): undefined | null
  /**
   * Reset the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is reset.
   * * `Err(napi::Error)` - If there is an error during the reset.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function resetDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.reset();
   * }
   *
   * resetDomain();
   * ```
   */
  reset(): number | null
  /**
   * Destroy/power-off the domain with flags.
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the destruction. Use VirDomainDestroyFlags enum
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is destroyed.
   * * `Err(napi::Error)` - If there is an error during the destruction.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * VIR_DOMAIN_DESTROY_GRACEFUL = 1 (0x1; 1 << 0)
   *
   * async function destroyDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.destroyFlags(VIR_DOMAIN_DESTROY_GRACEFUL);
   * }
   *
   * destroyDomain();
   * ```
   */
  destroyFlags(flags: number): number | null
  /**
   * Shutdown the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is shutdown.
   * * `Err(napi::Error)` - If there is an error during the shutdown.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function shutdownDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.shutdown();
   * }
   *
   * shutdownDomain();
   * ```
   */
  shutdown(): number | null
  /**
   * Reboot the domain with flags.
   * Useful if you want to send ACPI events to the domain.
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the reboot. Use VirDomainRebootFlag enum
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(())` - If the domain is rebooted.
   * * `Err(napi::Error)` - If there is an error during the reboot.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * const VIR_DOMAIN_REBOOT_ACPI_POWER_BTN = 1 (0x1; 1 << 1)
   *
   * async function rebootDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.reboot(VIR_DOMAIN_REBOOT_ACPI_POWER_BTN);
   * }
   *
   * rebootDomain();
   * ```
   */
  reboot(flags: number): undefined | null
  /**
   * Suspend the domain.
   * When machine is suspended, the process is frozen without further access to
   * CPU resources and I/O but the memory used by the domain at the hypervisor level
   * will stay allocated.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is suspended.
   * * `Err(napi::Error)` - If there is an error during the suspension.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function suspendDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.suspend();
   * }
   *
   * suspendDomain();
   * ```
   */
  suspend(): number | null
  /**
   * Resume the suspended domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is resumed.
   * * `Err(napi::Error)` - If there is an error during the resumption.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function resumeDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.resume();
   * }
   *
   * resumeDomain();
   * ```
   */
  resume(): number | null
  isActive(): boolean | null
  undefine(): number | null
  /**
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the undefinition. Use VirDomainUndefineFlags enum
   */
  undefineFlags(flags: number): number | null
  free(): number | null
  isUpdated(): boolean | null
  getAutostart(): boolean | null
  setAutostart(autostart: boolean): boolean | null
  setMaxMemory(memory: bigint): boolean | null
  getMaxVcpus(): bigint | null
  setMemory(memory: bigint): boolean | null
  /**
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the memory modification. Use VirDomainMemoryModFlags enum
   */
  setMemoryFlags(memory: bigint, flags: number): boolean | null
  /**
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the memory modification. Use VirDomainMemoryModFlags enum
   */
  setMemoryStatsPeriod(period: number, flags: number): boolean | null
  setVcpus(vcpus: number): boolean | null
  setVcpusFlags(vcpus: number, flags: number): boolean | null
  static domainRestore(conn: Connection, path: string): number | null
  static domainRestoreFlags(conn: Connection, path: string, flags: number): number | null
  getVcpusFlags(flags: number): number | null
  migrateSetMaxSpeed(bandwidth: bigint, flags: number): number | null
  migrateGetMaxSpeed(flags: number): bigint | null
  migrateSetCompressionCache(size: bigint, flags: number): number | null
  migrateGetCompressionCache(flags: number): bigint | null
  migrateSetMaxDowntime(downtime: bigint, flags: number): number | null
  setTime(seconds: number, nseconds: number, flags: number): number | null
  getTime(flags: number): Time | null
  getBlockInfo(disk: string, flags: number): BlockInfo | null
  pinVcpu(vcpu: number, cpumap: Uint8Array): number | null
  pinVcpuFlags(vcpu: number, cpumap: Uint8Array, flags: number): number | null
  pinEmulator(cpumap: Uint8Array, flags: number): number | null
  rename(newName: string, flags: number): number | null
  setUserPassword(user: string, password: string, flags: number): number | null
  setBlockThreshold(dev: string, threshold: bigint, flags: number): number | null
  openGraphics(idx: number, fd: number, flags: number): number | null
  openGraphicsFd(idx: number, flags: number): number | null
  interfaceStats(path: string): InterfaceStats | null
  memoryStats(flags: number): Array<MemoryStat> | null
  static saveImageGetXmlDesc(conn: Connection, file: string, flags: number): string | null
  static saveImageDefineXml(conn: Connection, file: string, dxml: string, flags: number): number | null
  attachDevice(xml: string): number | null
  attachDeviceFlags(xml: string, flags: number): number | null
  detachDevice(xml: string): number | null
  detachDeviceFlags(xml: string, flags: number): number | null
  updateDeviceFlags(xml: string, flags: number): number | null
  managedSave(flags: number): number | null
  hasManagedSave(flags: number): boolean | null
  managedSaveRemove(flags: number): number | null
  coreDump(to: string, flags: number): number | null
  coreDumpWithFormat(to: string, format: number, flags: number): number | null
  setMetadata(kind: number, metadata: string, key: string, uri: string, flags: number): number | null
  getMetadata(kind: number, uri: string, flags: number): string | null
  blockResize(disk: string, size: bigint, flags: number): number | null
  getMemoryParameters(flags: number): MemoryParameters | null
  setMemoryParameters(params: MemoryParameters, flags: number): number | null
  migrate(dconn: Connection, flags: number, uri: string, bandwidth: bigint): Machine | null
  migrateWithXml(dconn: Connection, dxml: string, flags: number, uri: string, bandwidth: bigint): Machine | null
  migrateToUri(uri: string, flags: number, bandwidth: bigint): number | null
  migrateToUriWithXml(dconnUri: string, migUri: string, dxml: string, flags: number, bandwidth: bigint): number | null
  getNumaParameters(flags: number): NumaParameters | null
  setNumaParameters(params: NumaParameters, flags: number): number | null
}
/** Contains information about a virtual machine. */
export declare class MachineInfo {
  /** The running state, one of virDomainState. */
  state: number
  /** The maximum memory in KBytes allowed. */
  maxMem: bigint
  /** The memory in KBytes used by the domain. */
  memory: bigint
  /** The number of virtual CPUs for the domain. */
  nrVirtCpu: number
  /** The CPU time used in nanoseconds. */
  cpuTime: bigint
}
/** Represents the time structure. */
export declare class Time {
  /** The seconds part of the time. */
  seconds: number
  /** The nanoseconds part of the time. */
  nseconds: number
}
/**
 * Represents the state result.
 * Check https://libvirt.org/html/libvirt-libvirt-domain.html#virDomainState
 */
export declare class StateResult {
  /** The result of the state. 0 if success, 1 if failure. */
  result: number
  /** The reason of the state. It's a flag, Check libvirt documentation for more info. */
  reason: number
}
/** Represents the block info. */
export declare class BlockInfo {
  /**
   * Logical size in bytes of the image (how much storage the guest
   * will see).
   */
  capacity: bigint
  /**
   * Host storage in bytes occupied by the image (such as highest
   * allocated extent if there are no holes, similar to 'du').
   */
  allocation: bigint
  /**
   * Host physical size in bytes of the image container (last
   * offset, similar to 'ls')
   */
  physical: bigint
}
export declare class InterfaceStats {
  rxBytes: number
  rxPackets: number
  rxErrs: number
  rxDrop: number
  txBytes: number
  txPackets: number
  txErrs: number
  txDrop: number
}
export declare class MemoryStat {
  tag: number
  val: bigint
}
export type NUMAParameters = NumaParameters
export declare class NumaParameters {
  /** Lists the numa nodeset of a domain. */
  nodeSet?: string
  /**
   * Numa mode of a domain, as an int containing a
   * DomainNumatuneMemMode value.
   */
  mode?: number
}
export declare class MemoryParameters {
  /** Represents the maximum memory the guest can use. */
  hardLimit?: bigint
  /**
   * Represents the memory upper limit enforced during memory
   * contention.
   */
  softLimit?: bigint
  /**
   * Represents the minimum memory guaranteed to be reserved for
   * the guest.
   */
  minGuarantee?: bigint
  /** Represents the maximum swap plus memory the guest can use. */
  swapHardLimit?: bigint
}
export declare class Network {
  static lookupByName(conn: Connection, name: string): Network | null
  static lookupByUuidString(conn: Connection, uuid: string): Network | null
  getName(): string | null
  getUuidString(): string | null
  getBridgeName(): string | null
  getXmlDesc(flags: number): string | null
  create(): number | null
  static defineXml(conn: Connection, xml: string): Network | null
  static createXml(conn: Connection, xml: string): Network | null
  destroy(): number | null
  undefine(): number | null
  free(): number | null
  isActive(): boolean | null
  isPersistent(): boolean | null
  getAutostart(): boolean | null
  setAutostart(autostart: boolean): number | null
  update(cmd: number, section: number, index: number, xml: string, flags: number): number | null
}
export declare class Interface { }
export declare class NodeDevice { }
export declare class Secret { }
export declare class StoragePool {
  static defineXml(conn: Connection, xml: string): StoragePool | null
  static createXml(conn: Connection, xml: string, flags: number): StoragePool | null
  static lookupByName(conn: Connection, name: string): StoragePool | null
  static lookupByUuidString(conn: Connection, uuid: string): StoragePool | null
  getName(): string | null
  numOfVolumes(): number | null
  listVolumes(): Array<string> | null
  getUuidString(): string | null
  getXmlDesc(): string | null
  create(flags: number): number | null
  build(flags: number): number | null
  destroy(): number | null
  undefine(): number | null
  free(): number | null
  isActive(): boolean | null
  isPersistent(): boolean | null
  refresh(flags: number): number | null
  getAutostart(): boolean | null
  setAutostart(autostart: boolean): number | null
  getInfo(): any | null
}
export declare class StorageVol {
  /**
   * Creates a new storage volume in the given storage pool.
   *
   * # Arguments
   *
   * * `pool` - A reference to the StoragePool where the volume will be created.
   * * `xml` - The XML description of the storage volume to create.
   * * `flags` - Bitwise-OR of virStorageVolCreateFlags.
   *
   * # Returns
   *
   * A Result containing the newly created StorageVol on success, or an Error on failure.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function createQcow2Disk() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *
   *   const volumeXml = `
   *     <volume>
   *       <name>mydisk.qcow2</name>
   *       <allocation>0</allocation>
   *       <capacity unit="G">20</capacity>
   *       <target>
   *         <format type='qcow2'/>
   *       </target>
   *     </volume>
   *   `;
   *
   *   const volume = await StorageVol.createXml(pool, volumeXml, 0);
   *   console.log(`Created volume: ${await volume.getName()}`);
   *
   *   await conn.close();
   * }
   *
   * createQcow2Disk().catch(console.error);
   * ```
   */
  static createXml(pool: StoragePool, xml: string, flags: number): StorageVol
  /**
   * Creates a storage volume, using an existing volume as input.
   *
   * # Arguments
   *
   * * `pool` - A reference to the StoragePool where the volume will be created.
   * * `xml` - The XML description of the storage volume to create.
   * * `vol` - The source StorageVol to clone from.
   * * `flags` - Bitwise-OR of virStorageVolCreateFlags.
   *
   * # Returns
   *
   * A Result containing the newly created StorageVol on success, or an Error on failure.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function cloneVolume() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *
   *   const sourceVolume = await StorageVol.lookupByName(pool, 'source_volume.qcow2');
   *
   *   const cloneXml = `
   *     <volume>
   *       <name>cloned_volume.qcow2</name>
   *       <capacity>0</capacity>
   *     </volume>
   *   `;
   *
   *   const clonedVolume = await StorageVol.createXmlFrom(pool, cloneXml, sourceVolume, 0);
   *   console.log(`Cloned volume: ${await clonedVolume.getName()}`);
   *
   *   await conn.close();
   * }
   *
   * cloneVolume().catch(console.error);
   * ```
   */
  static createXmlFrom(pool: StoragePool, xml: string, vol: StorageVol, flags: number): StorageVol
  /**
   * Deletes a storage volume.
   *
   * # Arguments
   *
   * * `flags` - Bitwise-OR of virStorageVolDeleteFlags.
   *
   * # Returns
   *
   * A Result containing () on success, or an Error on failure.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function deleteVolume() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *
   *   const volume = await StorageVol.lookupByName(pool, 'volume_to_delete.qcow2');
   *
   *   // Delete the volume
   *   // 0 is passed as flags to use default behavior
   *   await volume.delete(0);
   *
   *   console.log('Volume deleted successfully');
   *
   *   await conn.close();
   * }
   *
   * deleteVolume().catch(console.error);
   * ```
   */
  delete(flags: number): void
  /**
   * Retrieves information about a storage volume.
   *
   * # Returns
   *
   * A Result containing a JsObject with the following properties:
   * * `type`: The type of the storage volume (u32).
   * * `capacity`: The total capacity of the storage volume in bytes (BigInt).
   * * `allocation`: The current allocation of the storage volume in bytes (BigInt).
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function getVolumeInfo() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *   const volume = await StorageVol.lookupByName(pool, 'my_volume.qcow2');
   *
   *   const info = await volume.getInfo();
   *   console.log('Volume type:', info.type);
   *   console.log('Volume capacity:', info.capacity.toString());
   *   console.log('Volume allocation:', info.allocation.toString());
   *
   *   await conn.close();
   * }
   *
   * getVolumeInfo().catch(console.error);
   * ```
   */
  getInfo(): any
  /**
   * Retrieves the name of the storage volume.
   *
   * # Returns
   *
   * A Result containing a String with the name of the storage volume.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function getVolumeName() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *   const volume = await StorageVol.lookupByName(pool, 'my_volume.qcow2');
   *
   *   const name = await volume.getName();
   *   console.log('Volume name:', name);
   *
   *   await conn.close();
   * }
   *
   * getVolumeName().catch(console.error);
   * ```
   */
  getName(): string
  /**
   * Retrieves the path of the storage volume.
   *
   * # Returns
   *
   * A Result containing a String with the path of the storage volume.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function getVolumePath() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *   const volume = await StorageVol.lookupByName(pool, 'my_volume.qcow2');
   *
   *   const path = await volume.getPath();
   *   console.log('Volume path:', path);
   *
   *   await conn.close();
   * }
   *
   * getVolumePath().catch(console.error);
   * ```
   */
  getPath(): string
  /**
   * Retrieves the XML description of the storage volume.
   *
   * # Arguments
   *
   * * `flags` - Bitwise-OR of virStorageXMLFlags
   *
   * # Returns
   *
   * A Result containing a String with the XML description of the storage volume.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function getVolumeXMLDesc() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *   const volume = await StorageVol.lookupByName(pool, 'my_volume.qcow2');
   *
   *   const xmlDesc = await volume.getXMLDesc(0);
   *   console.log('Volume XML description:', xmlDesc);
   *
   *   await conn.close();
   * }
   *
   * getVolumeXMLDesc().catch(console.error);
   * ```
   */
  getXmlDesc(flags: number): string
  /**
   * Resizes a storage volume.
   *
   * # Arguments
   *
   * * `capacity` - New capacity for the volume, in bytes.
   * * `flags` - Bitwise-OR of virStorageVolResizeFlags
   *
   * # Returns
   *
   * A Result indicating success or failure of the operation.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function resizeVolume() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *   const volume = await StorageVol.lookupByName(pool, 'my_volume.qcow2');
   *
   *   // Resize the volume to 10 GB
   *   const newCapacity = BigInt(10 * 1024 * 1024 * 1024); // 10 GB in bytes
   *   await volume.resize(newCapacity, 0);
   *   console.log('Volume resized successfully');
   *
   *   await conn.close();
   * }
   *
   * resizeVolume().catch(console.error);
   * ```
   */
  resize(capacity: bigint, flags: number): void
  /**
   * Wipes a storage volume.
   *
   * This method erases all data from the storage volume.
   *
   * # Arguments
   *
   * * `flags` - Bitwise-OR of virStorageVolWipeFlags
   *
   * # Returns
   *
   * A Result indicating success or failure of the operation.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function wipeVolume() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *   const volume = await StorageVol.lookupByName(pool, 'my_volume.qcow2');
   *
   *   // Wipe the volume
   *   await volume.wipe(0);
   *   console.log('Volume wiped successfully');
   *
   *   await conn.close();
   * }
   *
   * wipeVolume().catch(console.error);
   * ```
   */
  wipe(flags: number): void
  /**
   * Looks up a storage volume based on its name within a storage pool.
   *
   * # Arguments
   *
   * * `pool` - A reference to the StoragePool to search in.
   * * `name` - The name of the storage volume to look up.
   *
   * # Returns
   *
   * A Result containing an Option<StorageVol>. If the volume is found, it returns Some(StorageVol).
   * If the volume is not found, it returns None. Other errors result in an Error.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function lookupVolume() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *
   *   const volume = await StorageVol.lookupByName(pool, 'my_volume.qcow2');
   *   if (volume) {
   *     console.log('Volume found:', await volume.getName());
   *   } else {
   *     console.log('Volume not found');
   *   }
   *
   *   await conn.close();
   * }
   *
   * lookupVolume().catch(console.error);
   * ```
   */
  static lookupByName(pool: StoragePool, name: string): StorageVol | null
  /**
   * Looks up a storage volume based on its unique key.
   *
   * # Arguments
   *
   * * `conn` - A reference to the Connection to use for the lookup.
   * * `key` - The unique key of the storage volume to look up.
   *
   * # Returns
   *
   * A Result containing an Option<StorageVol>. If the volume is found, it returns Some(StorageVol).
   * If the volume is not found, it returns None. Other errors result in an Error.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function lookupVolumeByKey() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *
   *   const volumeKey = '/path/to/volume/key';
   *   const volume = await StorageVol.lookupByKey(conn, volumeKey);
   *
   *   if (volume) {
   *     console.log('Volume found:', await volume.getName());
   *   } else {
   *     console.log('Volume not found');
   *   }
   *
   *   await conn.close();
   * }
   *
   * lookupVolumeByKey().catch(console.error);
   * ```
   */
  static lookupByKey(conn: Connection, key: string): StorageVol | null
  /**
   * Looks up a storage volume based on its path.
   *
   * # Arguments
   *
   * * `conn` - A reference to the Connection to use for the lookup.
   * * `path` - The path of the storage volume to look up.
   *
   * # Returns
   *
   * A Result containing an Option<StorageVol>. If the volume is found, it returns Some(StorageVol).
   * If the volume is not found, it returns None. Other errors result in an Error.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function lookupVolumeByPath() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *
   *   const volumePath = '/path/to/storage/volume.qcow2';
   *   const volume = await StorageVol.lookupByPath(conn, volumePath);
   *
   *   if (volume) {
   *     console.log('Volume found:', await volume.getName());
   *   } else {
   *     console.log('Volume not found');
   *   }
   *
   *   await conn.close();
   * }
   *
   * lookupVolumeByPath().catch(console.error);
   * ```
   */
  static lookupByPath(conn: Connection, path: string): StorageVol | null
  /**
   * Frees the storage volume object.
   *
   * This method should be called when the storage volume object is no longer needed.
   * It releases the resources associated with the object.
   *
   * # Returns
   *
   * A Result containing () on success, or an Error on failure.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function freeStorageVolume() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *   const volume = await StorageVol.lookupByName(pool, 'my_volume.qcow2');
   *
   *   // Use the volume...
   *
   *   // Free the volume when done
   *   await volume.free();
   *
   *   console.log('Volume freed successfully');
   *
   *   await conn.close();
   * }
   *
   * freeStorageVolume().catch(console.error);
   * ```
   *
   * Note: After calling this method, the StorageVol object should not be used anymore.
   */
  free(): void
  /**
   * Wipes a storage volume using a specific algorithm.
   *
   * This method erases the data on the storage volume using the specified wiping algorithm.
   *
   * # Arguments
   *
   * * `algorithm` - The algorithm to use for wiping. See virStorageVolWipeAlgorithm for possible values.
   * * `flags` - Bitwise-OR of virStorageVolWipeFlags.
   *
   * # Returns
   *
   * A Result containing () on success, or an Error on failure.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function wipeVolume() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *   const volume = await StorageVol.lookupByName(pool, 'volume_to_wipe.qcow2');
   *
   *   // Wipe the volume using zero-fill algorithm
   *   // 0 is VIR_STORAGE_VOL_WIPE_ALG_ZERO
   *   // 0 is passed as flags to use default behavior
   *   await volume.wipePattern(0, 0);
   *
   *   console.log('Volume wiped successfully');
   *
   *   await conn.close();
   * }
   *
   * wipeVolume().catch(console.error);
   * ```
   *
   * Note: This operation may take a long time depending on the size of the volume and the chosen algorithm.
   */
  wipePattern(algorithm: number, flags: number): void
}
export type NWFilter = NwFilter
export declare class NwFilter { }
export declare class NodeInfo { }
export declare class DomainStatsRecord { }
export declare class Error {
  static lastError(): Error
}
