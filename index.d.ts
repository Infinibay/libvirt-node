/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export const enum VirDomainGetHostnameFlags {
  /** Parse DHCP lease file */
  VirDomainGetHostnameLease = 1,
  /** Query qemu guest agent */
  VirDomainGetHostnameAgent = 2
}
export const enum VirDomainXMLFlags {
  /** dump security sensitive information too */
  VirDomainXMLSecure = 1,
  /** dump inactive domain information */
  VirDomainXMLInactive = 2,
  /** update guest CPU requirements according to host CPU */
  VirDomainXMLUpdateCPU = 4,
  /** dump XML suitable for migration */
  VirDomainXMLMigratable = 8
}
export const enum VirDomainCreateFlags {
  /** Default behavior */
  VirDomainNone = 0,
  /** Launch guest in paused state */
  VirDomainStartPaused = 1,
  /** Automatically kill guest when virConnectPtr is closed */
  VirDomainStartAutodestroy = 2,
  /** Avoid file system cache pollution */
  VirDomainStartBypassCache = 4,
  /** Boot, discarding any managed save */
  VirDomainStartForceBoot = 8,
  /** Validate the XML document against schema */
  VirDomainStartValidate = 16,
  /** Re-initialize NVRAM from template */
  VirDomainStartResetNvram = 32
}
export const enum VirDomainDefineFlags {
  /** Validate the XML document against schema */
  VirDomainDefineValidate = 1
}
export const enum VirDomainDestroyFlags {
  /** Default behavior - could lead to data loss!! */
  VirDomainDestroyDefault = 0,
  /** Only SIGTERM, no SIGKILL */
  VirDomainDestroyGraceful = 1,
  /** Remove VM logs on destroy */
  VirDomainDestroyRemoveLogs = 2
}
export const enum VirDomainRebootFlag {
  /** Hypervisor choice */
  VirDomainRebootDefault = 0,
  /** Send ACPI event */
  VirDomainRebootAcpiPowerBtn = 1,
  /** Use guest agent */
  VirDomainRebootGuestAgent = 2,
  /** Use initctl */
  VirDomainRebootInitctl = 4,
  /** Send a signal */
  VirDomainRebootSignal = 8,
  /** Use paravirt guest control */
  VirDomainRebootParavirt = 16
}
export const enum VirDomainUndefineFlags {
  /** Also remove any managed save */
  VirDomainUndefineManagedSave = 1,
  /** If last use of domain, then also remove any snapshot metadata */
  VirDomainUndefineSnapshotsMetadata = 2,
  /** Also remove any nvram file */
  VirDomainUndefineNvram = 4,
  /** Keep nvram file */
  VirDomainUndefineKeepNvram = 8,
  /** If last use of domain, then also remove any checkpoint metadata */
  VirDomainUndefineCheckpointsMetadata = 16,
  /** Also remove any TPM state */
  VirDomainUndefineTpm = 32,
  /** Keep TPM state */
  VirDomainUndefineKeepTpm = 64
}
export const enum VirDomainModificationImpact {
  /** Affect current domain state */
  VirDomainAffectCurrent = 0,
  /** Affect running domain state */
  VirDomainAffectLive = 1,
  /** Affect persistent domain state */
  VirDomainAffectConfig = 2
}
export const enum VirDomainMemoryModFlags {
  /** See virDomainModificationImpact */
  VirDomainMemConfig = 2,
  /** See virDomainModificationImpact */
  VirDomainMemCurrent = 0,
  /** See virDomainModificationImpact */
  VirDomainMemLive = 1,
  /** Affect Max rather than current */
  VirDomainMemMaximum = 4
}
export class Connection {
  static open(name: string): Connection
  isAlive(): boolean
  getSysInfo(flags: number): string
  getMaxVcpus(attr: string): number
  getCpuModelsNames(arch: string, flags: number): Array<string>
  isEncrypted(): boolean
  isSecure(): boolean
  listActiveDomainIds(): Array<number>
  listInterfaces(): Array<string>
  listNetworks(): Array<string>
  listNwFilters(): Array<string>
  listSecrets(): Array<string>
  listStoragePools(): Array<string>
  listAllDomains(flags: number): Array<Machine>
  listAllNetworks(flags: number): Array<Network>
  listAllInterfaces(flags: number): Array<Interface>
  listAllNodeDevices(flags: number): Array<NodeDevice>
  listAllSecrets(flags: number): Array<Secret>
  listAllStoragePools(flags: number): Array<StoragePool>
  listAllNwFilters(flags: number): Array<NWFilter>
  listDefinedDomains(): Array<string>
  listDefinedInterfaces(): Array<string>
  listDefinedStoragePools(): Array<string>
  listDefinedNetworks(): Array<string>
  numOfDomains(): number
  numOfInterfaces(): number
  numOfNetworks(): number
  numOfStoragePools(): number
  numOfNwFilters(): number
  numOfSecrets(): number
  numOfNodeDevices(): number
  numOfDefinedDomains(): number
  numOfDefinedInterfaces(): number
  numOfDefinedNetworks(): number
  getHypVersion(): number
  compareCpu(xml: string, flags: number): number
  getFreeMemory(): bigint
  getNodeInfo(): NodeInfo
  setKeepAlive(interval: number, count: number): number
  domainXmlFromNative(nformat: string, nconfig: string, flags: number): string
  domainXmlToNative(nformat: string, dxml: string, flags: number): string
  getDomainCapabilities(emulatorbin: string, arch: string, machine: string, virttype: string, flags: number): string
  getAllDomainStats(stats: number, flags: number): Array<DomainStatsRecord>
  baselineCpu(xmlcpus: Array<string>, flags: number): string
  findStoragePoolSources(kind: string, spec: string, flags: number): string
}
/** Represents a virtual machine. */
export class Machine {
  /**
   * Looks up a domain by its name.
   *
   * # Arguments
   *
   * * `name` - A string slice that holds the name of the domain.
   * * `con` - A reference to the Connection object.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(Machine)` - If the domain is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function lookupDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   try {
   *     const machine = await Machine.lookupByName('your-domain-name', conn);
   *     console.log('Domain found:', machine);
   *   } catch (err) {
   *     console.error('Error looking up domain:', err);
   *   }
   * }
   *
   * lookupDomain();
   * ```
   */
  static lookupByName(name: string, con: Connection): this
  /**
   * Looks up a domain by its ID.
   *
   * # Arguments
   *
   * * `conn` - A reference to the Connection object.
   * * `id` - The ID of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(Machine)` - If the domain is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function lookupDomainById() {
   *   const conn = Connection.open('quemu:///system');
   *   try {
   *     const machine = await Machine.lookupById(conn, 1); // Replace 1 with your domain ID
   *     console.log('Domain found:', machine);
   *   } catch (err) {
   *     console.error('Error looking up domain by ID:', err);
   *   }
   * }
   *
   * lookupDomainById();
   * ```
   */
  static lookupById(conn: Connection, id: number): Machine
  /**
   * Looks up a domain by its UUID.
   *
   * # Arguments
   *
   * * `conn` - A reference to the Connection object.
   * * `uuid` - The UUID of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(Machine)` - If the domain is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function lookupDomainByUuid() {
   *   const conn = Connection.open('quemu:///system');
   *   try {
   *     const machine = await Machine.lookupByUuidString(conn, 'your-domain-uuid');
   *     console.log('Domain found:', machine);
   *   } catch (err) {
   *     console.error('Error looking up domain by UUID:', err);
   *   }
   * }
   *
   * lookupDomainByUuid();
   * ```
   */
  static lookupByUuidString(conn: Connection, uuid: string): Machine
  /**
   * Get the state of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(StateResult)` - If the state is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   * const VIR_DOMAIN_RUNNING = 1;
   *
   * async function getDomainState() {
   *   const conn = Connection.open('quemu:///system');
   *   try {
   *     const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *     const state = await machine.getState();
   *     if (state.result === VIR_DOMAIN_RUNNING) {
   *       console.log('Domain is running');
   *     } else {
   *       console.log('Domain is not running');
   *     }
   *   } catch (err) {
   *     console.error('Error looking up domain by UUID:', err);
   *   }
   * }
   *
   * getDomainState();
   * ```
   */
  getState(): StateResult
  /**
   * Get the name of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(String)` - If the name is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainName() {
   *   const conn = Connection.open('quemu:///system');
   *   try {
   *     const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *     const name = await machine.get_name();
   *     console.log('Domain name:', name);
   *   } catch (err) {
   *     console.error('Error looking up domain by UUID:', err);
   *   }
   * }
   *
   * getDomainName();
   * ```
   */
  getName(): string
  /**
   * Get the OS type of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(String)` - If the OS type is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainOsType() {
   *   const conn = Connection.open('quemu:///system');
   *   try {
   *     const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *     const osType = await machine.getOsType();
   *     console.log('Domain OS type:', osType);
   *   } catch (err) {
   *     console.error('Error looking up domain by UUID:', err);
   *   }
   * }
   *
   * getDomainOsType();
   * ```
   */
  getOsType(): string
  /**
   * Get the hostname of the domain.
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the lookup. Use VirDomainGetHostnameFlags enum
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(String)` - If the hostname is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainHostname() {
   *   const conn = Connection.open('quemu:///system');
   *   try {
   *     const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *     const hostname = await machine.getHostname();
   *     console.log('Domain hostname:', hostname);
   *   } catch (err) {
   *     console.error('Error looking up domain by UUID:', err);
   *   }
   * }
   *
   * getDomainHostname();
   * ```
   */
  getHostname(flags: number): string
  /**
   * Get the UUID of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(String)` - If the UUID is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainUuid() {
   *   const conn = Connection.open('quemu:///system');
   *   try {
   *     const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *     const uuid = await machine.getUuid();
   *     console.log('Domain UUID:', uuid);
   *   } catch (err) {
   *     console.error('Error looking up domain by name:', err);
   *   }
   * }
   *
   * getDomainUuid();
   * ```
   */
  getUuidString(): string
  /**
   * Get the ID of the domain.
   *
   * # Returns
   *
   * This function returns an `Option` which is:
   * * `Some(u32)` - If the ID is found.
   * * `None` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainId() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   const id = machine.get_id();
   *   console.log('Domain ID:', id);
   * }
   *
   * getDomainId();
   * ```
   */
  getId(): number | null
  /**
   * Get the XML description of the domain.
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the lookup. Use VirDomainXMLFlags enum
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(String)` - If the XML description is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainXml() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   const xml = await machine.getXml();
   *   console.log('Domain XML:', xml);
   * }
   *
   * getDomainXml();
   * ```
   */
  getXmlDesc(flags: number): string
  /**
   * Create/power-on the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is created.
   * * `Err(napi::Error)` - If there is an error during the creation.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function createDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.create();
   * }
   *
   * createDomain();
   * ```
   */
  create(): number
  /**
   * Create/power-on the domain with flags.
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the creation. Use VirDomainCreateFlags enum
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is created.
   * * `Err(napi::Error)` - If there is an error during the creation.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * const VIR_DOMAIN_START_PAUSED = 1;
   *
   * async function createDomainWithFlags() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.createWithFlags(VIR_DOMAIN_START_PAUSED);
   * }
   *
   * createDomainWithFlags();
   * ```
   */
  createWithFlags(flags: number): number
  /**
   * Get the information of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(MachineInfo)` - If the information is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainInfo() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   const info = await machine.getInfo();
   *   console.log('Domain info:', info);
   * }
   *
   * getDomainInfo();
   * ```
   */
  getInfo(): MachineInfo
  /**
   * Create a domain from an XML description.
   *
   * # Arguments
   *
   * * `xml` - The XML description of the domain.
   * * `flags` - The flags to use for the creation. Use VirDomainCreateFlags enum
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(Machine)` - If the domain is created.
   * * `Err(napi::Error)` - If there is an error during the creation.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function createDomainFromXml() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.createXml(conn, 'your-domain-xml', 0);
   *   // Now, we can power on the domain
   *   await machine.create();
   * }
   *
   * createDomainFromXml();
   * ```
   */
  static createXml(conn: Connection, xml: string, flags: number): Machine
  /**
   * Define a domain from an XML description.
   *
   * # Arguments
   *
   * * `xml` - The XML description of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(Machine)` - If the domain is defined.
   * * `Err(napi::Error)` - If there is an error during the definition.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function defineDomainFromXml() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.defineXml(conn, 'your-domain-xml');
   * }
   *
   * defineDomainFromXml();
   * ```
   */
  static defineXml(conn: Connection, xml: string): Machine
  /**
   * Define a domain from an XML description with flags.
   *
   * # Arguments
   *
   * * `xml` - The XML description of the domain.
   * * `flags` - The flags to use for the definition. Use VirDomainDefineFlags enum
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(Machine)` - If the domain is defined.
   * * `Err(napi::Error)` - If there is an error during the definition.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function defineDomainFromXml() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.defineXml(conn, 'your-domain-xml');
   * }
   *
   * defineDomainFromXml();
   * ```
   */
  static defineXmlFlags(conn: Connection, xml: string, flags: number): Machine
  /**
   * Destroy/power-off the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(())` - If the domain is destroyed.
   * * `Err(napi::Error)` - If there is an error during the destruction.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function destroyDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.destroy();
   * }
   *
   * destroyDomain();
   * ```
   */
  destroy(): void
  /**
   * Reset the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is reset.
   * * `Err(napi::Error)` - If there is an error during the reset.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function resetDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.reset();
   * }
   *
   * resetDomain();
   * ```
   */
  reset(): number
  /**
   * Destroy/power-off the domain with flags.
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the destruction. Use VirDomainDestroyFlags enum
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is destroyed.
   * * `Err(napi::Error)` - If there is an error during the destruction.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * VIR_DOMAIN_DESTROY_GRACEFUL = 1 (0x1; 1 << 0)
   *
   * async function destroyDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.destroyFlags(VIR_DOMAIN_DESTROY_GRACEFUL);
   * }
   *
   * destroyDomain();
   * ```
   */
  destroyFlags(flags: number): number
  /**
   * Shutdown the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is shutdown.
   * * `Err(napi::Error)` - If there is an error during the shutdown.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function shutdownDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.shutdown();
   * }
   *
   * shutdownDomain();
   * ```
   */
  shutdown(): number
  /**
   * Reboot the domain with flags.
   * Useful if you want to send ACPI events to the domain.
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the reboot. Use VirDomainRebootFlag enum
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(())` - If the domain is rebooted.
   * * `Err(napi::Error)` - If there is an error during the reboot.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * const VIR_DOMAIN_REBOOT_ACPI_POWER_BTN = 1 (0x1; 1 << 1)
   *
   * async function rebootDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.reboot(VIR_DOMAIN_REBOOT_ACPI_POWER_BTN);
   * }
   *
   * rebootDomain();
   * ```
   */
  reboot(flags: number): void
  /**
   * Suspend the domain.
   * When machine is suspended, the process is frozen without further access to
   * CPU resources and I/O but the memory used by the domain at the hypervisor level
   * will stay allocated.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is suspended.
   * * `Err(napi::Error)` - If there is an error during the suspension.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function suspendDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.suspend();
   * }
   *
   * suspendDomain();
   * ```
   */
  suspend(): number
  /**
   * Resume the suspended domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is resumed.
   * * `Err(napi::Error)` - If there is an error during the resumption.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function resumeDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.resume();
   * }
   *
   * resumeDomain();
   * ```
   */
  resume(): number
  isActive(): boolean
  undefine(): void
  /**
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the undefinition. Use VirDomainUndefineFlags enum
   */
  undefineFlags(flags: number): void
  free(): void
  isUpdated(): boolean
  getAutostart(): boolean
  setAutostart(autostart: boolean): boolean
  setMaxMemory(memory: bigint): boolean
  getMaxVcpus(): bigint
  setMemory(memory: bigint): boolean
  /**
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the memory modification. Use VirDomainMemoryModFlags enum
   */
  setMemoryFlags(memory: bigint, flags: number): boolean
  /**
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the memory modification. Use VirDomainMemoryModFlags enum
   */
  setMemoryStatsPeriod(period: number, flags: number): boolean
  setVcpus(vcpus: number): boolean
  setVcpusFlags(vcpus: number, flags: number): boolean
  static domainRestore(conn: Connection, path: string): void
  static domainRestoreFlags(conn: Connection, path: string, flags: number): void
  getVcpusFlags(flags: number): number
  migrateSetMaxSpeed(bandwidth: bigint, flags: number): number
  migrateGetMaxSpeed(flags: number): bigint
  migrateSetCompressionCache(size: bigint, flags: number): number
  migrateGetCompressionCache(flags: number): bigint
  migrateSetMaxDowntime(downtime: bigint, flags: number): number
  setTime(seconds: number, nseconds: number, flags: number): number
  getTime(flags: number): Time
  getBlockInfo(disk: string, flags: number): BlockInfo
  pinVcpu(vcpu: number, cpumap: Uint8Array): number
  pinVcpuFlags(vcpu: number, cpumap: Uint8Array, flags: number): number
  pinEmulator(cpumap: Uint8Array, flags: number): number
  rename(newName: string, flags: number): number
  setUserPassword(user: string, password: string, flags: number): number
  setBlockThreshold(dev: string, threshold: bigint, flags: number): number
  openGraphics(idx: number, fd: number, flags: number): number
  openGraphicsFd(idx: number, flags: number): number
  interfaceStats(path: string): InterfaceStats
  memoryStats(flags: number): Array<MemoryStat>
  static saveImageGetXmlDesc(conn: Connection, file: string, flags: number): string
  static saveImageDefineXml(conn: Connection, file: string, dxml: string, flags: number): number
  attachDevice(xml: string): number
  attachDeviceFlags(xml: string, flags: number): number
  detachDevice(xml: string): number
  detachDeviceFlags(xml: string, flags: number): number
  updateDeviceFlags(xml: string, flags: number): number
  managedSave(flags: number): number
  hasManagedSave(flags: number): boolean
  managedSaveRemove(flags: number): number
  coreDump(to: string, flags: number): number
  coreDumpWithFormat(to: string, format: number, flags: number): number
  setMetadata(kind: number, metadata: string, key: string, uri: string, flags: number): number
  getMetadata(kind: number, uri: string, flags: number): string
  blockResize(disk: string, size: bigint, flags: number): number
  getMemoryParameters(flags: number): MemoryParameters
  setMemoryParameters(params: MemoryParameters, flags: number): number
  migrate(dconn: Connection, flags: number, uri: string, bandwidth: bigint): this
  migrateWithXml(dconn: Connection, dxml: string, flags: number, uri: string, bandwidth: bigint): this
  migrateToUri(uri: string, flags: number, bandwidth: bigint): number
  migrateToUriWithXml(dconnUri: string, migUri: string, dxml: string, flags: number, bandwidth: bigint): number
  getNumaParameters(flags: number): NumaParameters
  setNumaParameters(params: NumaParameters, flags: number): number
}
/** Contains information about a virtual machine. */
export class MachineInfo {
  /** The running state, one of virDomainState. */
  state: number
  /** The maximum memory in KBytes allowed. */
  maxMem: bigint
  /** The memory in KBytes used by the domain. */
  memory: bigint
  /** The number of virtual CPUs for the domain. */
  nrVirtCpu: number
  /** The CPU time used in nanoseconds. */
  cpuTime: bigint
}
/** Represents the time structure. */
export class Time {
  /** The seconds part of the time. */
  seconds: number
  /** The nanoseconds part of the time. */
  nseconds: number
}
/**
 * Represents the state result.
 * Check https://libvirt.org/html/libvirt-libvirt-domain.html#virDomainState
 */
export class StateResult {
  /** The result of the state. 0 if success, 1 if failure. */
  result: number
  /** The reason of the state. It's a flag, Check libvirt documentation for more info. */
  reason: number
}
/** Represents the block info. */
export class BlockInfo {
  /**
   * Logical size in bytes of the image (how much storage the guest
   * will see).
   */
  capacity: bigint
  /**
   * Host storage in bytes occupied by the image (such as highest
   * allocated extent if there are no holes, similar to 'du').
   */
  allocation: bigint
  /**
   * Host physical size in bytes of the image container (last
   * offset, similar to 'ls')
   */
  physical: bigint
}
export class InterfaceStats {
  rxBytes: number
  rxPackets: number
  rxErrs: number
  rxDrop: number
  txBytes: number
  txPackets: number
  txErrs: number
  txDrop: number
}
export class MemoryStat {
  tag: number
  val: bigint
}
export type NUMAParameters = NumaParameters
export class NumaParameters {
  /** Lists the numa nodeset of a domain. */
  nodeSet?: string
  /**
   * Numa mode of a domain, as an int containing a
   * DomainNumatuneMemMode value.
   */
  mode?: number
}
export class MemoryParameters {
  /** Represents the maximum memory the guest can use. */
  hardLimit?: bigint
  /**
   * Represents the memory upper limit enforced during memory
   * contention.
   */
  softLimit?: bigint
  /**
   * Represents the minimum memory guaranteed to be reserved for
   * the guest.
   */
  minGuarantee?: bigint
  /** Represents the maximum swap plus memory the guest can use. */
  swapHardLimit?: bigint
}
export class Network { }
export class Interface { }
export class NodeDevice { }
export class Secret { }
export class StoragePool { }
export type NWFilter = NwFilter
export class NwFilter { }
export class NodeInfo { }
export class DomainStatsRecord { }
