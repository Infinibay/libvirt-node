/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export const enum VirDomainGetHostnameFlags {
  /** Parse DHCP lease file */
  VirDomainGetHostnameLease = 1,
  /** Query qemu guest agent */
  VirDomainGetHostnameAgent = 2
}
export const enum VirDomainXMLFlags {
  /** dump security sensitive information too */
  VirDomainXMLSecure = 1,
  /** dump inactive domain information */
  VirDomainXMLInactive = 2,
  /** update guest CPU requirements according to host CPU */
  VirDomainXMLUpdateCPU = 4,
  /** dump XML suitable for migration */
  VirDomainXMLMigratable = 8
}
export const enum VirDomainCreateFlags {
  /** Default behavior */
  VirDomainNone = 0,
  /** Launch guest in paused state */
  VirDomainStartPaused = 1,
  /** Automatically kill guest when virConnectPtr is closed */
  VirDomainStartAutodestroy = 2,
  /** Avoid file system cache pollution */
  VirDomainStartBypassCache = 4,
  /** Boot, discarding any managed save */
  VirDomainStartForceBoot = 8,
  /** Validate the XML document against schema */
  VirDomainStartValidate = 16,
  /** Re-initialize NVRAM from template */
  VirDomainStartResetNvram = 32
}
export const enum VirDomainDefineFlags {
  /** Validate the XML document against schema */
  VirDomainDefineValidate = 1
}
export const enum VirDomainDestroyFlags {
  /** Default behavior - could lead to data loss!! */
  VirDomainDestroyDefault = 0,
  /** Only SIGTERM, no SIGKILL */
  VirDomainDestroyGraceful = 1,
  /** Remove VM logs on destroy */
  VirDomainDestroyRemoveLogs = 2
}
export const enum VirDomainRebootFlag {
  /** Hypervisor choice */
  VirDomainRebootDefault = 0,
  /** Send ACPI event */
  VirDomainRebootAcpiPowerBtn = 1,
  /** Use guest agent */
  VirDomainRebootGuestAgent = 2,
  /** Use initctl */
  VirDomainRebootInitctl = 4,
  /** Send a signal */
  VirDomainRebootSignal = 8,
  /** Use paravirt guest control */
  VirDomainRebootParavirt = 16
}
export const enum VirDomainUndefineFlags {
  /** Also remove any managed save */
  VirDomainUndefineManagedSave = 1,
  /** If last use of domain, then also remove any snapshot metadata */
  VirDomainUndefineSnapshotsMetadata = 2,
  /** Also remove any nvram file */
  VirDomainUndefineNvram = 4,
  /** Keep nvram file */
  VirDomainUndefineKeepNvram = 8,
  /** If last use of domain, then also remove any checkpoint metadata */
  VirDomainUndefineCheckpointsMetadata = 16,
  /** Also remove any TPM state */
  VirDomainUndefineTpm = 32,
  /** Keep TPM state */
  VirDomainUndefineKeepTpm = 64
}
export const enum VirDomainModificationImpact {
  /** Affect current domain state */
  VirDomainAffectCurrent = 0,
  /** Affect running domain state */
  VirDomainAffectLive = 1,
  /** Affect persistent domain state */
  VirDomainAffectConfig = 2
}
export const enum VirDomainMemoryModFlags {
  /** See virDomainModificationImpact */
  VirDomainMemConfig = 2,
  /** See virDomainModificationImpact */
  VirDomainMemCurrent = 0,
  /** See virDomainModificationImpact */
  VirDomainMemLive = 1,
  /** Affect Max rather than current */
  VirDomainMemMaximum = 4
}
export const enum VirStoragePoolCreateFlags {
  /** Default behavior */
  VirStoragePoolCreateNormal = 0,
  /** Create pool from XML, build it */
  VirStoragePoolCreateWithBuild = 1,
  /** Create pool from XML, build it and overwrite if exists */
  VirStoragePoolCreateWithBuildOverwrite = 2,
  /** Create pool from XML, build it and do not overwrite if exists */
  VirStoragePoolCreateWithBuildNoOverwrite = 4
}
export const enum VirStorageXMLFlags {
  /** Inactive */
  VirStorageXMLInactive = 1
}
export class Connection {
  static open(name: string): Connection
  close(): void
  isAlive(): boolean
  getSysInfo(flags: number): string
  getMaxVcpus(attr: string): number
  getCpuModelsNames(arch: string, flags: number): Array<string>
  isEncrypted(): boolean
  isSecure(): boolean
  listActiveDomainIds(): Array<number>
  listInterfaces(): Array<string>
  listNetworks(): Array<string>
  listNwFilters(): Array<string>
  listSecrets(): Array<string>
  listStoragePools(): Array<string>
  listAllDomains(flags: number): Array<Machine>
  listAllNetworks(flags: number): Array<Network>
  listAllInterfaces(flags: number): Array<Interface>
  listAllNodeDevices(flags: number): Array<NodeDevice>
  listAllSecrets(flags: number): Array<Secret>
  listAllStoragePools(flags: number): Array<StoragePool>
  listAllNwFilters(flags: number): Array<NWFilter>
  listDefinedDomains(): Array<string>
  listDefinedInterfaces(): Array<string>
  listDefinedStoragePools(): Array<string>
  listDefinedNetworks(): Array<string>
  numOfDomains(): number
  numOfInterfaces(): number
  numOfNetworks(): number
  numOfStoragePools(): number
  numOfNwFilters(): number
  numOfSecrets(): number
  numOfNodeDevices(): number
  numOfDefinedDomains(): number
  numOfDefinedInterfaces(): number
  numOfDefinedNetworks(): number
  getHypVersion(): number
  compareCpu(xml: string, flags: number): number
  getFreeMemory(): bigint
  getNodeInfo(): NodeInfo
  setKeepAlive(interval: number, count: number): number
  domainXmlFromNative(nformat: string, nconfig: string, flags: number): string
  domainXmlToNative(nformat: string, dxml: string, flags: number): string
  getDomainCapabilities(emulatorbin: string, arch: string, machine: string, virttype: string, flags: number): string
  getAllDomainStats(stats: number, flags: number): Array<DomainStatsRecord>
  baselineCpu(xmlcpus: Array<string>, flags: number): string
  findStoragePoolSources(kind: string, spec: string, flags: number): string
}
/** Represents a virtual machine. */
export class Machine {
  /**
   * Looks up a domain by its name.
   *
   * # Arguments
   *
   * * `name` - A string slice that holds the name of the domain.
   * * `con` - A reference to the Connection object.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(Machine)` - If the domain is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function lookupDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   try {
   *     const machine = await Machine.lookupByName('your-domain-name', conn);
   *     console.log('Domain found:', machine);
   *   } catch (err) {
   *     console.error('Error looking up domain:', err);
   *   }
   * }
   *
   * lookupDomain();
   * ```
   */
  static lookupByName(name: string, con: Connection): this
  /**
   * Looks up a domain by its ID.
   *
   * # Arguments
   *
   * * `conn` - A reference to the Connection object.
   * * `id` - The ID of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(Machine)` - If the domain is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function lookupDomainById() {
   *   const conn = Connection.open('quemu:///system');
   *   try {
   *     const machine = await Machine.lookupById(conn, 1); // Replace 1 with your domain ID
   *     console.log('Domain found:', machine);
   *   } catch (err) {
   *     console.error('Error looking up domain by ID:', err);
   *   }
   * }
   *
   * lookupDomainById();
   * ```
   */
  static lookupById(conn: Connection, id: number): Machine
  /**
   * Looks up a domain by its UUID.
   *
   * # Arguments
   *
   * * `conn` - A reference to the Connection object.
   * * `uuid` - The UUID of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(Machine)` - If the domain is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function lookupDomainByUuid() {
   *   const conn = Connection.open('quemu:///system');
   *   try {
   *     const machine = await Machine.lookupByUuidString(conn, 'your-domain-uuid');
   *     console.log('Domain found:', machine);
   *   } catch (err) {
   *     console.error('Error looking up domain by UUID:', err);
   *   }
   * }
   *
   * lookupDomainByUuid();
   * ```
   */
  static lookupByUuidString(conn: Connection, uuid: string): Machine
  /**
   * Get the state of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(StateResult)` - If the state is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   * const VIR_DOMAIN_RUNNING = 1;
   *
   * async function getDomainState() {
   *   const conn = Connection.open('quemu:///system');
   *   try {
   *     const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *     const state = await machine.getState();
   *     if (state.result === VIR_DOMAIN_RUNNING) {
   *       console.log('Domain is running');
   *     } else {
   *       console.log('Domain is not running');
   *     }
   *   } catch (err) {
   *     console.error('Error looking up domain by UUID:', err);
   *   }
   * }
   *
   * getDomainState();
   * ```
   */
  getState(): StateResult
  /**
   * Get the name of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(String)` - If the name is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainName() {
   *   const conn = Connection.open('quemu:///system');
   *   try {
   *     const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *     const name = await machine.get_name();
   *     console.log('Domain name:', name);
   *   } catch (err) {
   *     console.error('Error looking up domain by UUID:', err);
   *   }
   * }
   *
   * getDomainName();
   * ```
   */
  getName(): string
  /**
   * Get the OS type of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(String)` - If the OS type is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainOsType() {
   *   const conn = Connection.open('quemu:///system');
   *   try {
   *     const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *     const osType = await machine.getOsType();
   *     console.log('Domain OS type:', osType);
   *   } catch (err) {
   *     console.error('Error looking up domain by UUID:', err);
   *   }
   * }
   *
   * getDomainOsType();
   * ```
   */
  getOsType(): string
  /**
   * Get the hostname of the domain.
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the lookup. Use VirDomainGetHostnameFlags enum
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(String)` - If the hostname is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainHostname() {
   *   const conn = Connection.open('quemu:///system');
   *   try {
   *     const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *     const hostname = await machine.getHostname();
   *     console.log('Domain hostname:', hostname);
   *   } catch (err) {
   *     console.error('Error looking up domain by UUID:', err);
   *   }
   * }
   *
   * getDomainHostname();
   * ```
   */
  getHostname(flags: number): string
  /**
   * Get the UUID of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(String)` - If the UUID is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainUuid() {
   *   const conn = Connection.open('quemu:///system');
   *   try {
   *     const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *     const uuid = await machine.getUuid();
   *     console.log('Domain UUID:', uuid);
   *   } catch (err) {
   *     console.error('Error looking up domain by name:', err);
   *   }
   * }
   *
   * getDomainUuid();
   * ```
   */
  getUuidString(): string
  /**
   * Get the ID of the domain.
   *
   * # Returns
   *
   * This function returns an `Option` which is:
   * * `Some(u32)` - If the ID is found.
   * * `None` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainId() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   const id = machine.get_id();
   *   console.log('Domain ID:', id);
   * }
   *
   * getDomainId();
   * ```
   */
  getId(): number | null
  /**
   * Get the XML description of the domain.
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the lookup. Use VirDomainXMLFlags enum
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(String)` - If the XML description is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainXml() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   const xml = await machine.getXml();
   *   console.log('Domain XML:', xml);
   * }
   *
   * getDomainXml();
   * ```
   */
  getXmlDesc(flags: number): string
  /**
   * Create/power-on the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is created.
   * * `Err(napi::Error)` - If there is an error during the creation.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function createDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.create();
   * }
   *
   * createDomain();
   * ```
   */
  create(): number
  /**
   * Create/power-on the domain with flags.
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the creation. Use VirDomainCreateFlags enum
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is created.
   * * `Err(napi::Error)` - If there is an error during the creation.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * const VIR_DOMAIN_START_PAUSED = 1;
   *
   * async function createDomainWithFlags() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.createWithFlags(VIR_DOMAIN_START_PAUSED);
   * }
   *
   * createDomainWithFlags();
   * ```
   */
  createWithFlags(flags: number): number
  /**
   * Get the information of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(MachineInfo)` - If the information is found.
   * * `Err(napi::Error)` - If there is an error during the lookup.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function getDomainInfo() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   const info = await machine.getInfo();
   *   console.log('Domain info:', info);
   * }
   *
   * getDomainInfo();
   * ```
   */
  getInfo(): MachineInfo
  /**
   * Create a domain from an XML description.
   *
   * # Arguments
   *
   * * `xml` - The XML description of the domain.
   * * `flags` - The flags to use for the creation. Use VirDomainCreateFlags enum
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(Machine)` - If the domain is created.
   * * `Err(napi::Error)` - If there is an error during the creation.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function createDomainFromXml() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.createXml(conn, 'your-domain-xml', 0);
   *   // Now, we can power on the domain
   *   await machine.create();
   * }
   *
   * createDomainFromXml();
   * ```
   */
  static createXml(conn: Connection, xml: string, flags: number): Machine
  /**
   * Define a domain from an XML description.
   *
   * # Arguments
   *
   * * `xml` - The XML description of the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(Machine)` - If the domain is defined.
   * * `Err(napi::Error)` - If there is an error during the definition.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function defineDomainFromXml() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.defineXml(conn, 'your-domain-xml');
   * }
   *
   * defineDomainFromXml();
   * ```
   */
  static defineXml(conn: Connection, xml: string): Machine
  /**
   * Define a domain from an XML description with flags.
   *
   * # Arguments
   *
   * * `xml` - The XML description of the domain.
   * * `flags` - The flags to use for the definition. Use VirDomainDefineFlags enum
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(Machine)` - If the domain is defined.
   * * `Err(napi::Error)` - If there is an error during the definition.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function defineDomainFromXml() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.defineXml(conn, 'your-domain-xml');
   * }
   *
   * defineDomainFromXml();
   * ```
   */
  static defineXmlFlags(conn: Connection, xml: string, flags: number): Machine
  /**
   * Destroy/power-off the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(())` - If the domain is destroyed.
   * * `Err(napi::Error)` - If there is an error during the destruction.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function destroyDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.destroy();
   * }
   *
   * destroyDomain();
   * ```
   */
  destroy(): void
  /**
   * Reset the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is reset.
   * * `Err(napi::Error)` - If there is an error during the reset.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function resetDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.reset();
   * }
   *
   * resetDomain();
   * ```
   */
  reset(): number
  /**
   * Destroy/power-off the domain with flags.
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the destruction. Use VirDomainDestroyFlags enum
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is destroyed.
   * * `Err(napi::Error)` - If there is an error during the destruction.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * VIR_DOMAIN_DESTROY_GRACEFUL = 1 (0x1; 1 << 0)
   *
   * async function destroyDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.destroyFlags(VIR_DOMAIN_DESTROY_GRACEFUL);
   * }
   *
   * destroyDomain();
   * ```
   */
  destroyFlags(flags: number): number
  /**
   * Shutdown the domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is shutdown.
   * * `Err(napi::Error)` - If there is an error during the shutdown.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function shutdownDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.shutdown();
   * }
   *
   * shutdownDomain();
   * ```
   */
  shutdown(): number
  /**
   * Reboot the domain with flags.
   * Useful if you want to send ACPI events to the domain.
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the reboot. Use VirDomainRebootFlag enum
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(())` - If the domain is rebooted.
   * * `Err(napi::Error)` - If there is an error during the reboot.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * const VIR_DOMAIN_REBOOT_ACPI_POWER_BTN = 1 (0x1; 1 << 1)
   *
   * async function rebootDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.reboot(VIR_DOMAIN_REBOOT_ACPI_POWER_BTN);
   * }
   *
   * rebootDomain();
   * ```
   */
  reboot(flags: number): void
  /**
   * Suspend the domain.
   * When machine is suspended, the process is frozen without further access to
   * CPU resources and I/O but the memory used by the domain at the hypervisor level
   * will stay allocated.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is suspended.
   * * `Err(napi::Error)` - If there is an error during the suspension.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function suspendDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.suspend();
   * }
   *
   * suspendDomain();
   * ```
   */
  suspend(): number
  /**
   * Resume the suspended domain.
   *
   * # Returns
   *
   * This function returns a `Result` which is:
   * * `Ok(u32)` - If the domain is resumed.
   * * `Err(napi::Error)` - If there is an error during the resumption.
   *
   * # Example (in JavaScript)
   *
   * ```javascript
   * const { Connection, Machine } = require('your-node-package');
   *
   * async function resumeDomain() {
   *   const conn = Connection.open('quemu:///system');
   *   const machine = await Machine.lookupByName(conn, 'your-domain-name');
   *   await machine.resume();
   * }
   *
   * resumeDomain();
   * ```
   */
  resume(): number
  isActive(): boolean
  undefine(): void
  /**
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the undefinition. Use VirDomainUndefineFlags enum
   */
  undefineFlags(flags: number): void
  free(): void
  isUpdated(): boolean
  getAutostart(): boolean
  setAutostart(autostart: boolean): boolean
  setMaxMemory(memory: bigint): boolean
  getMaxVcpus(): bigint
  setMemory(memory: bigint): boolean
  /**
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the memory modification. Use VirDomainMemoryModFlags enum
   */
  setMemoryFlags(memory: bigint, flags: number): boolean
  /**
   *
   * # Arguments
   *
   * * `flags` - The flags to use for the memory modification. Use VirDomainMemoryModFlags enum
   */
  setMemoryStatsPeriod(period: number, flags: number): boolean
  setVcpus(vcpus: number): boolean
  setVcpusFlags(vcpus: number, flags: number): boolean
  static domainRestore(conn: Connection, path: string): void
  static domainRestoreFlags(conn: Connection, path: string, flags: number): void
  getVcpusFlags(flags: number): number
  migrateSetMaxSpeed(bandwidth: bigint, flags: number): number
  migrateGetMaxSpeed(flags: number): bigint
  migrateSetCompressionCache(size: bigint, flags: number): number
  migrateGetCompressionCache(flags: number): bigint
  migrateSetMaxDowntime(downtime: bigint, flags: number): number
  setTime(seconds: number, nseconds: number, flags: number): number
  getTime(flags: number): Time
  getBlockInfo(disk: string, flags: number): BlockInfo
  pinVcpu(vcpu: number, cpumap: Uint8Array): number
  pinVcpuFlags(vcpu: number, cpumap: Uint8Array, flags: number): number
  pinEmulator(cpumap: Uint8Array, flags: number): number
  rename(newName: string, flags: number): number
  setUserPassword(user: string, password: string, flags: number): number
  setBlockThreshold(dev: string, threshold: bigint, flags: number): number
  openGraphics(idx: number, fd: number, flags: number): number
  openGraphicsFd(idx: number, flags: number): number
  interfaceStats(path: string): InterfaceStats
  memoryStats(flags: number): Array<MemoryStat>
  static saveImageGetXmlDesc(conn: Connection, file: string, flags: number): string
  static saveImageDefineXml(conn: Connection, file: string, dxml: string, flags: number): number
  attachDevice(xml: string): number
  attachDeviceFlags(xml: string, flags: number): number
  detachDevice(xml: string): number
  detachDeviceFlags(xml: string, flags: number): number
  updateDeviceFlags(xml: string, flags: number): number
  managedSave(flags: number): number
  hasManagedSave(flags: number): boolean
  managedSaveRemove(flags: number): number
  coreDump(to: string, flags: number): number
  coreDumpWithFormat(to: string, format: number, flags: number): number
  setMetadata(kind: number, metadata: string, key: string, uri: string, flags: number): number
  getMetadata(kind: number, uri: string, flags: number): string
  blockResize(disk: string, size: bigint, flags: number): number
  getMemoryParameters(flags: number): MemoryParameters
  setMemoryParameters(params: MemoryParameters, flags: number): number
  migrate(dconn: Connection, flags: number, uri: string, bandwidth: bigint): this
  migrateWithXml(dconn: Connection, dxml: string, flags: number, uri: string, bandwidth: bigint): this
  migrateToUri(uri: string, flags: number, bandwidth: bigint): number
  migrateToUriWithXml(dconnUri: string, migUri: string, dxml: string, flags: number, bandwidth: bigint): number
  getNumaParameters(flags: number): NumaParameters
  setNumaParameters(params: NumaParameters, flags: number): number
}
/** Contains information about a virtual machine. */
export class MachineInfo {
  /** The running state, one of virDomainState. */
  state: number
  /** The maximum memory in KBytes allowed. */
  maxMem: bigint
  /** The memory in KBytes used by the domain. */
  memory: bigint
  /** The number of virtual CPUs for the domain. */
  nrVirtCpu: number
  /** The CPU time used in nanoseconds. */
  cpuTime: bigint
}
/** Represents the time structure. */
export class Time {
  /** The seconds part of the time. */
  seconds: number
  /** The nanoseconds part of the time. */
  nseconds: number
}
/**
 * Represents the state result.
 * Check https://libvirt.org/html/libvirt-libvirt-domain.html#virDomainState
 */
export class StateResult {
  /** The result of the state. 0 if success, 1 if failure. */
  result: number
  /** The reason of the state. It's a flag, Check libvirt documentation for more info. */
  reason: number
}
/** Represents the block info. */
export class BlockInfo {
  /**
   * Logical size in bytes of the image (how much storage the guest
   * will see).
   */
  capacity: bigint
  /**
   * Host storage in bytes occupied by the image (such as highest
   * allocated extent if there are no holes, similar to 'du').
   */
  allocation: bigint
  /**
   * Host physical size in bytes of the image container (last
   * offset, similar to 'ls')
   */
  physical: bigint
}
export class InterfaceStats {
  rxBytes: number
  rxPackets: number
  rxErrs: number
  rxDrop: number
  txBytes: number
  txPackets: number
  txErrs: number
  txDrop: number
}
export class MemoryStat {
  tag: number
  val: bigint
}
export type NUMAParameters = NumaParameters
export class NumaParameters {
  /** Lists the numa nodeset of a domain. */
  nodeSet?: string
  /**
   * Numa mode of a domain, as an int containing a
   * DomainNumatuneMemMode value.
   */
  mode?: number
}
export class MemoryParameters {
  /** Represents the maximum memory the guest can use. */
  hardLimit?: bigint
  /**
   * Represents the memory upper limit enforced during memory
   * contention.
   */
  softLimit?: bigint
  /**
   * Represents the minimum memory guaranteed to be reserved for
   * the guest.
   */
  minGuarantee?: bigint
  /** Represents the maximum swap plus memory the guest can use. */
  swapHardLimit?: bigint
}
export class Network { }
export class Interface { }
export class NodeDevice { }
export class Secret { }
export class StoragePool {
  static defineXml(conn: Connection, xml: string): StoragePool
  static createXml(conn: Connection, xml: string, flags: number): StoragePool
  static lookupByName(conn: Connection, name: string): StoragePool
  static lookupByUuidString(conn: Connection, uuid: string): StoragePool
  getName(): string
  numOfVolumes(): number
  listVolumes(): Array<string>
  getUuidString(): string
  getXmlDesc(): string
  create(flags: number): number
  build(flags: number): number
  destroy(): void
  undefine(): void
  free(): void
  isActive(): boolean
  isPersistent(): boolean
  refresh(flags: number): void
  getAutostart(): boolean
  setAutostart(autostart: boolean): void
  getInfo(): any
}
export class StorageVol {
  /**
   * Creates a new storage volume in the given storage pool.
   *
   * # Arguments
   *
   * * `pool` - A reference to the StoragePool where the volume will be created.
   * * `xml` - The XML description of the storage volume to create.
   * * `flags` - Bitwise-OR of virStorageVolCreateFlags.
   *
   * # Returns
   *
   * A Result containing the newly created StorageVol on success, or an Error on failure.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function createQcow2Disk() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *
   *   const volumeXml = `
   *     <volume>
   *       <name>mydisk.qcow2</name>
   *       <allocation>0</allocation>
   *       <capacity unit="G">20</capacity>
   *       <target>
   *         <format type='qcow2'/>
   *       </target>
   *     </volume>
   *   `;
   *
   *   const volume = await StorageVol.createXml(pool, volumeXml, 0);
   *   console.log(`Created volume: ${await volume.getName()}`);
   *
   *   await conn.close();
   * }
   *
   * createQcow2Disk().catch(console.error);
   * ```
   */
  static createXml(pool: StoragePool, xml: string, flags: number): NapiResult
  /**
   * Creates a storage volume, using an existing volume as input.
   *
   * # Arguments
   *
   * * `pool` - A reference to the StoragePool where the volume will be created.
   * * `xml` - The XML description of the storage volume to create.
   * * `vol` - The source StorageVol to clone from.
   * * `flags` - Bitwise-OR of virStorageVolCreateFlags.
   *
   * # Returns
   *
   * A Result containing the newly created StorageVol on success, or an Error on failure.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function cloneVolume() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *
   *   const sourceVolume = await StorageVol.lookupByName(pool, 'source_volume.qcow2');
   *
   *   const cloneXml = `
   *     <volume>
   *       <name>cloned_volume.qcow2</name>
   *       <capacity>0</capacity>
   *     </volume>
   *   `;
   *
   *   const clonedVolume = await StorageVol.createXmlFrom(pool, cloneXml, sourceVolume, 0);
   *   console.log(`Cloned volume: ${await clonedVolume.getName()}`);
   *
   *   await conn.close();
   * }
   *
   * cloneVolume().catch(console.error);
   * ```
   */
  static createXmlFrom(pool: StoragePool, xml: string, vol: StorageVol, flags: number): NapiResult
  /**
   * Deletes a storage volume.
   *
   * # Arguments
   *
   * * `flags` - Bitwise-OR of virStorageVolDeleteFlags.
   *
   * # Returns
   *
   * A Result containing () on success, or an Error on failure.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function deleteVolume() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *
   *   const volume = await StorageVol.lookupByName(pool, 'volume_to_delete.qcow2');
   *
   *   // Delete the volume
   *   // 0 is passed as flags to use default behavior
   *   await volume.delete(0);
   *
   *   console.log('Volume deleted successfully');
   *
   *   await conn.close();
   * }
   *
   * deleteVolume().catch(console.error);
   * ```
   */
  delete(flags: number): NapiResult
  /**
   * Retrieves information about a storage volume.
   *
   * # Returns
   *
   * A Result containing a JsObject with the following properties:
   * * `type`: The type of the storage volume (u32).
   * * `capacity`: The total capacity of the storage volume in bytes (BigInt).
   * * `allocation`: The current allocation of the storage volume in bytes (BigInt).
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function getVolumeInfo() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *   const volume = await StorageVol.lookupByName(pool, 'my_volume.qcow2');
   *
   *   const info = await volume.getInfo();
   *   console.log('Volume type:', info.type);
   *   console.log('Volume capacity:', info.capacity.toString());
   *   console.log('Volume allocation:', info.allocation.toString());
   *
   *   await conn.close();
   * }
   *
   * getVolumeInfo().catch(console.error);
   * ```
   */
  getInfo(): NapiResult
  /**
   * Retrieves the name of the storage volume.
   *
   * # Returns
   *
   * A Result containing a String with the name of the storage volume.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function getVolumeName() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *   const volume = await StorageVol.lookupByName(pool, 'my_volume.qcow2');
   *
   *   const name = await volume.getName();
   *   console.log('Volume name:', name);
   *
   *   await conn.close();
   * }
   *
   * getVolumeName().catch(console.error);
   * ```
   */
  getName(): NapiResult
  /**
   * Retrieves the path of the storage volume.
   *
   * # Returns
   *
   * A Result containing a String with the path of the storage volume.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function getVolumePath() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *   const volume = await StorageVol.lookupByName(pool, 'my_volume.qcow2');
   *
   *   const path = await volume.getPath();
   *   console.log('Volume path:', path);
   *
   *   await conn.close();
   * }
   *
   * getVolumePath().catch(console.error);
   * ```
   */
  getPath(): NapiResult
  /**
   * Retrieves the XML description of the storage volume.
   *
   * # Arguments
   *
   * * `flags` - Bitwise-OR of virStorageXMLFlags
   *
   * # Returns
   *
   * A Result containing a String with the XML description of the storage volume.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function getVolumeXMLDesc() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *   const volume = await StorageVol.lookupByName(pool, 'my_volume.qcow2');
   *
   *   const xmlDesc = await volume.getXMLDesc(0);
   *   console.log('Volume XML description:', xmlDesc);
   *
   *   await conn.close();
   * }
   *
   * getVolumeXMLDesc().catch(console.error);
   * ```
   */
  getXmlDesc(flags: number): NapiResult
  /**
   * Resizes a storage volume.
   *
   * # Arguments
   *
   * * `capacity` - New capacity for the volume, in bytes.
   * * `flags` - Bitwise-OR of virStorageVolResizeFlags
   *
   * # Returns
   *
   * A Result indicating success or failure of the operation.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function resizeVolume() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *   const volume = await StorageVol.lookupByName(pool, 'my_volume.qcow2');
   *
   *   // Resize the volume to 10 GB
   *   const newCapacity = BigInt(10 * 1024 * 1024 * 1024); // 10 GB in bytes
   *   await volume.resize(newCapacity, 0);
   *   console.log('Volume resized successfully');
   *
   *   await conn.close();
   * }
   *
   * resizeVolume().catch(console.error);
   * ```
   */
  resize(capacity: bigint, flags: number): NapiResult
  /**
   * Wipes a storage volume.
   *
   * This method erases all data from the storage volume.
   *
   * # Arguments
   *
   * * `flags` - Bitwise-OR of virStorageVolWipeFlags
   *
   * # Returns
   *
   * A Result indicating success or failure of the operation.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function wipeVolume() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *   const volume = await StorageVol.lookupByName(pool, 'my_volume.qcow2');
   *
   *   // Wipe the volume
   *   await volume.wipe(0);
   *   console.log('Volume wiped successfully');
   *
   *   await conn.close();
   * }
   *
   * wipeVolume().catch(console.error);
   * ```
   */
  wipe(flags: number): NapiResult
  /**
   * Looks up a storage volume based on its name within a storage pool.
   *
   * # Arguments
   *
   * * `pool` - A reference to the StoragePool to search in.
   * * `name` - The name of the storage volume to look up.
   *
   * # Returns
   *
   * A Result containing an Option<StorageVol>. If the volume is found, it returns Some(StorageVol).
   * If the volume is not found, it returns None. Other errors result in an Error.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function lookupVolume() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *
   *   const volume = await StorageVol.lookupByName(pool, 'my_volume.qcow2');
   *   if (volume) {
   *     console.log('Volume found:', await volume.getName());
   *   } else {
   *     console.log('Volume not found');
   *   }
   *
   *   await conn.close();
   * }
   *
   * lookupVolume().catch(console.error);
   * ```
   */
  static lookupByName(pool: StoragePool, name: string): NapiResult
  /**
   * Looks up a storage volume based on its unique key.
   *
   * # Arguments
   *
   * * `conn` - A reference to the Connection to use for the lookup.
   * * `key` - The unique key of the storage volume to look up.
   *
   * # Returns
   *
   * A Result containing an Option<StorageVol>. If the volume is found, it returns Some(StorageVol).
   * If the volume is not found, it returns None. Other errors result in an Error.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function lookupVolumeByKey() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *
   *   const volumeKey = '/path/to/volume/key';
   *   const volume = await StorageVol.lookupByKey(conn, volumeKey);
   *
   *   if (volume) {
   *     console.log('Volume found:', await volume.getName());
   *   } else {
   *     console.log('Volume not found');
   *   }
   *
   *   await conn.close();
   * }
   *
   * lookupVolumeByKey().catch(console.error);
   * ```
   */
  static lookupByKey(conn: Connection, key: string): NapiResult
  /**
   * Looks up a storage volume based on its path.
   *
   * # Arguments
   *
   * * `conn` - A reference to the Connection to use for the lookup.
   * * `path` - The path of the storage volume to look up.
   *
   * # Returns
   *
   * A Result containing an Option<StorageVol>. If the volume is found, it returns Some(StorageVol).
   * If the volume is not found, it returns None. Other errors result in an Error.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function lookupVolumeByPath() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *
   *   const volumePath = '/path/to/storage/volume.qcow2';
   *   const volume = await StorageVol.lookupByPath(conn, volumePath);
   *
   *   if (volume) {
   *     console.log('Volume found:', await volume.getName());
   *   } else {
   *     console.log('Volume not found');
   *   }
   *
   *   await conn.close();
   * }
   *
   * lookupVolumeByPath().catch(console.error);
   * ```
   */
  static lookupByPath(conn: Connection, path: string): NapiResult
  /**
   * Frees the storage volume object.
   *
   * This method should be called when the storage volume object is no longer needed.
   * It releases the resources associated with the object.
   *
   * # Returns
   *
   * A Result containing () on success, or an Error on failure.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function freeStorageVolume() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *   const volume = await StorageVol.lookupByName(pool, 'my_volume.qcow2');
   *
   *   // Use the volume...
   *
   *   // Free the volume when done
   *   await volume.free();
   *
   *   console.log('Volume freed successfully');
   *
   *   await conn.close();
   * }
   *
   * freeStorageVolume().catch(console.error);
   * ```
   *
   * Note: After calling this method, the StorageVol object should not be used anymore.
   */
  free(): NapiResult
  /**
   * Wipes a storage volume using a specific algorithm.
   *
   * This method erases the data on the storage volume using the specified wiping algorithm.
   *
   * # Arguments
   *
   * * `algorithm` - The algorithm to use for wiping. See virStorageVolWipeAlgorithm for possible values.
   * * `flags` - Bitwise-OR of virStorageVolWipeFlags.
   *
   * # Returns
   *
   * A Result containing () on success, or an Error on failure.
   *
   * # Example
   *
   * ```javascript
   * const libvirt = require('libvirt');
   *
   * async function wipeVolume() {
   *   const conn = await libvirt.Connection.open('qemu:///system');
   *   const pool = await conn.storagePoolLookupByName('default');
   *   const volume = await StorageVol.lookupByName(pool, 'volume_to_wipe.qcow2');
   *
   *   // Wipe the volume using zero-fill algorithm
   *   // 0 is VIR_STORAGE_VOL_WIPE_ALG_ZERO
   *   // 0 is passed as flags to use default behavior
   *   await volume.wipePattern(0, 0);
   *
   *   console.log('Volume wiped successfully');
   *
   *   await conn.close();
   * }
   *
   * wipeVolume().catch(console.error);
   * ```
   *
   * Note: This operation may take a long time depending on the size of the volume and the chosen algorithm.
   */
  wipePattern(algorithm: number, flags: number): NapiResult
}
export type NWFilter = NwFilter
export class NwFilter { }
export class NodeInfo { }
export class DomainStatsRecord { }
